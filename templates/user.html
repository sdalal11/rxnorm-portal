<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RxNorm - Document Portal</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }


        
        .auth-container {
            background: white;
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 400px;
        }
        
        .user-portal {
            display: none;
            background: white;
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 1200px;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .auth-header {
            text-align: center;
            margin-bottom: 2rem;
            color: #333;
        }
        
        .auth-header h2 {
            color: #667eea;
            margin-bottom: 0.5rem;
        }
        
        .auth-tabs {
            display: flex;
            margin-bottom: 2rem;
            border-bottom: 1px solid #eee;
        }
        
        .auth-tab {
            flex: 1;
            padding: 1rem;
            text-align: center;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.3s;
            font-weight: 600;
        }
        
        .auth-tab.active {
            border-bottom-color: #667eea;
            color: #667eea;
        }
        
        .auth-tab:hover {
            background-color: #f8f9fa;
        }
        
        .form-group {
            margin-bottom: 1.5rem;
        }
        
        label {
            display: block;
            margin-bottom: 0.5rem;
            color: #555;
            font-weight: bold;
        }
        
        input[type="text"], input[type="email"], input[type="password"], select, textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 1rem;
            box-sizing: border-box;
            transition: border-color 0.3s;
        }
        
        input[type="text"]:focus, input[type="email"]:focus, input[type="password"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
        }
        
        .btn {
            width: 100%;
            padding: 0.75rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-bottom: 1rem;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }
        
        .btn-secondary {
            background: #6c757d;
            margin-top: 1rem;
        }
        
        .btn-danger {
            background: #dc3545;
        }
        
        .error-message, .success-message {
            text-align: center;
            margin-top: 1rem;
            padding: 0.75rem;
            border-radius: 8px;
            display: none;
        }
        
        .error-message {
            color: #721c24;
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
        }
        
        .success-message {
            color: #155724;
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
        }
        
        .portal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid #eee;
        }
        
        .welcome-text {
            color: #333;
        }
        
        .welcome-text h2 {
            color: #667eea;
            margin: 0;
        }
        
        .folder-assignment-info {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            margin-top: 12px;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }
        
        .assignment-badge {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 500;
        }
        
        .folder-icon {
            font-size: 16px;
        }
        
        .assignment-order {
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .assignment-details {
            margin-top: 4px;
            opacity: 0.9;
            font-size: 12px;
        }
        
        .logout-btn {
            padding: 0.5rem 1rem;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
        }
        
        .logout-btn:hover {
            background: #c82333;
        }
        
        .search-section {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: #f8f9fa;
            border-radius: 12px;
            border: 1px solid #e9ecef;
        }
        
        .search-controls {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            align-items: end;
        }
        
        .search-group {
            flex: 1;
            min-width: 200px;
        }
        
        .search-btn {
            padding: 0.75rem 1.5rem;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            white-space: nowrap;
        }
        
        .search-btn:hover {
            background: #5a6fd8;
        }
        
        .documents-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-top: 2rem;
        }
        
        .document-card {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 12px;
            padding: 1.5rem;
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
        }
        
        .document-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        }
        
        .document-icon {
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.5rem;
            margin-bottom: 1rem;
        }
        
        .document-title {
            font-size: 1.1rem;
            font-weight: bold;
            color: #333;
            margin-bottom: 0.5rem;
        }
        
        .document-meta {
            font-size: 0.875rem;
            color: #666;
            margin-bottom: 1rem;
        }
        
        .document-description {
            font-size: 0.875rem;
            color: #777;
            margin-bottom: 1rem;
            line-height: 1.4;
        }
        
        .document-actions {
            display: flex;
            gap: 0.5rem;
        }
        
        .btn-small {
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            flex: 1;
            text-align: center;
        }
        
        .btn-view {
            background: #17a2b8;
            color: white;
        }
        
        .btn-download {
            background: #28a745;
            color: white;
        }
        
        .btn-view:hover {
            background: #138496;
        }
        
        .btn-download:hover {
            background: #218838;
        }
        
        .category-badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            font-size: 0.75rem;
            font-weight: 600;
            border-radius: 12px;
            margin-bottom: 0.5rem;
        }
        
        .badge-general { background: #e3f2fd; color: #1976d2; }
        .badge-medical { background: #f3e5f5; color: #7b1fa2; }
        .badge-reports { background: #e8f5e8; color: #388e3c; }
        .badge-policies { background: #fff3e0; color: #f57c00; }
        .badge-training { background: #fce4ec; color: #c2185b; }
        .badge-research { background: #e0f2f1; color: #00796b; }
        
        .no-documents {
            text-align: center;
            padding: 3rem;
            color: #666;
        }
        
        .no-documents h3 {
            color: #667eea;
            margin-bottom: 1rem;
        }
        
        .stats-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1.5rem;
            border-radius: 12px;
            text-align: center;
        }
        
        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }
        
        .stat-label {
            font-size: 0.875rem;
            opacity: 0.9;
        }
        
        .auth-form {
            display: none;
        }
        
        .auth-form.active {
            display: block;
        }
        
        @media (max-width: 768px) {
            .documents-grid {
                grid-template-columns: 1fr;
            }
            
            .search-controls {
                flex-direction: column;
            }
            
            .search-group {
                min-width: auto;
            }
        }
        
        /* Folder View Styles */
        .breadcrumb {
            background: #f8f9fa;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            font-size: 0.875rem;
            border: 1px solid #e9ecef;
        }
        
        .breadcrumb-item {
            color: #007bff;
            cursor: pointer;
            text-decoration: none;
        }
        
        .breadcrumb-item:hover {
            text-decoration: underline;
        }
        
        .breadcrumb-separator {
            margin: 0 0.5rem;
            color: #6c757d;
        }
        
        .folder-card {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            padding: 1.5rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            border-left: 4px solid #6f42c1;
        }
        
        .folder-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(111, 66, 193, 0.2);
            border-color: #6f42c1;
        }
        
        .folder-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            display: block;
        }
        
        .folder-title {
            font-weight: bold;
            color: #333;
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }
        
        .folder-meta {
            color: #666;
            font-size: 0.875rem;
        }
        
        .folder-badge {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: #6f42c1;
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: bold;
        }

        
        /* Folder View Styles */
        .breadcrumb {
            background: #f8f9fa;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            font-size: 0.875rem;
            border: 1px solid #e9ecef;
        }
        
        .breadcrumb-item {
            color: #007bff;
            cursor: pointer;
            text-decoration: none;
        }
        
        .breadcrumb-item:hover {
            text-decoration: underline;
        }
        
        .breadcrumb-separator {
            margin: 0 0.5rem;
            color: #6c757d;
        }
        
        .folder-card {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            padding: 1.5rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            border-left: 4px solid #6f42c1;
        }
        
        .folder-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(111, 66, 193, 0.2);
            border-color: #6f42c1;
        }
        
        .folder-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            display: block;
        }
        
        .folder-title {
            font-weight: bold;
            color: #333;
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }
        
        .folder-meta {
            color: #666;
            font-size: 0.875rem;
        }
        
        .folder-badge {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: #6f42c1;
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: bold;
        }

        .document-viewer {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000; /* Lower than annotations panel */
        }

        .viewer-content {
            position: relative;
            width: 90%;
            height: 90%;
            margin: 5% auto;
            background: white;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
        }

        .viewer-header {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f8f9fa;
            border-radius: 12px 12px 0 0;
        }

        .viewer-title {
            font-size: 1.2rem;
            font-weight: bold;
            color: #333;
        }

        .viewer-toolbar {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .annotation-btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }

        .btn-active {
            background: #28a745;
            color: white;
        }

        .btn-inactive {
            background: #dc3545;
            color: white;
        }

        .btn-clear {
            background: #6c757d;
            color: white;
        }

        .btn-close {
            background: #f8f9fa;
            color: #333;
            border: 1px solid #ddd;
        }

        .annotation-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .viewer-body {
            flex: 1;
            padding: 1.5rem;
            overflow-y: auto;
            position: relative;
        }

        .document-content {
            line-height: 1.6;
            font-size: 1rem;
            color: #333;
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
        }

        .document-body-content {
            max-width: none !important;
            margin: 0 !important;
            padding: 1rem;
            line-height: 1.6;
            font-family: Arial, sans-serif;
        }

        .document-body-content * {
            user-select: text !important;
            -webkit-user-select: text !important;
            -moz-user-select: text !important;
            -ms-user-select: text !important;
        }

        .document-content {
            cursor: text;
        }

        .document-content p, 
        .document-content div, 
        .document-content span {
            cursor: text;
        }

        /* Annotation styles */
        .highlight-active {
            background-color: #d4edda;
            border: 2px solid #28a745;
            border-radius: 3px;
            padding: 2px 4px;
            position: relative;
            cursor: pointer;
        }

        .highlight-inactive {
            background-color: #f8d7da;
            border: 2px solid #dc3545;
            border-radius: 3px;
            padding: 2px 4px;
            position: relative;
            cursor: pointer;
        }

        .highlight-active::after {
            content: "ACTIVE";
            position: absolute;
            top: -20px;
            left: 0;
            background: #28a745;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.7rem;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            z-index: 10;
        }

        .highlight-inactive::after {
            content: "INACTIVE";
            position: absolute;
            top: -20px;
            left: 0;
            background: #dc3545;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.7rem;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            z-index: 10;
        }

        .highlight-active:hover::after,
        .highlight-inactive:hover::after {
            opacity: 1;
        }

        .selection-popup {
            position: absolute;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            padding: 0.5rem;
            display: none;
            z-index: 100;
        }

        .selection-popup button {
            margin: 0 0.25rem;
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 600;
        }

        .annotations-panel {
            position: fixed;
            top: 10%;
            right: 20px;
            width: 300px;
            max-height: 70%;
            background: white;
            border: 1px solid #ddd;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            display: none;
            z-index: 1050; /* Higher than document viewer */
        }

        .annotations-header {
            padding: 1rem;
            border-bottom: 1px solid #eee;
            background: #f8f9fa;
            border-radius: 12px 12px 0 0;
        }

        .annotations-list {
            max-height: 400px;
            overflow-y: auto;
            padding: 1rem;
        }

        .annotation-item {
            padding: 0.75rem;
            border: 1px solid #eee;
            border-radius: 8px;
            margin-bottom: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .annotation-item:hover {
            border-color: #667eea;
            background: #f8f9ff;
            transform: translateX(2px);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.2);
        }

        .annotation-item:hover::before {
            content: "Click to locate in document";
            position: absolute;
            top: -30px;
            left: 0;
            background: #333;
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.7rem;
            white-space: nowrap;
            opacity: 0.9;
            z-index: 100;
        }

        .annotation-item:active {
            transform: translateX(0px);
            background: #e3f2fd;
        }

        .annotation-text {
            font-size: 0.875rem;
            color: #333;
            margin-bottom: 0.5rem;
            font-style: italic;
        }

        .annotation-status {
            font-size: 0.75rem;
            font-weight: bold;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            display: inline-block;
        }

        .status-active {
            background: #d4edda;
            color: #28a745;
        }

        .status-inactive {
            background: #f8d7da;
            color: #dc3545;
        }

        /* Style for annotation notes */
        .annotation-notes {
            margin-top: 0.5rem;
        }

        .annotation-notes textarea {
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .annotation-notes textarea:focus {
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.2);
            outline: none;
        }

        .annotation-notes textarea:not(:empty) {
            border-color: #28a745;
            background-color: #f8fff9;
        }

        /* Visual indicator for annotations with notes */
        .annotation-item.has-notes {
            border-left: 4px solid #17a2b8;
        }

        .annotation-item.has-notes::after {
            content: "üìù";
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            font-size: 0.8rem;
            opacity: 0.7;
        }

        @media (max-width: 768px) {
            .viewer-content {
                width: 95%;
                height: 95%;
                margin: 2.5% auto;
            }
            
            .annotations-panel {
                position: fixed;
                top: auto;
                bottom: 20px;
                right: 20px;
                left: 20px;
                width: auto;
                max-height: 50%;
            }
        }
    </style>
</head>
<body>
    <!-- Authentication Section -->
    <div class="auth-container" id="authContainer">
        <div class="auth-header">
            <h2>RxNorm Document Portal</h2>
            <p>Access medical documents and resources</p>
        </div>
        
        <!-- Auth Tabs -->
        <div class="auth-tabs">
            <div class="auth-tab active" onclick="showAuthTab('login')">Login</div>
            <div class="auth-tab" onclick="showAuthTab('register')">Register</div>
        </div>
        
        <!-- Login Form -->
        <div id="loginForm" class="auth-form active">
            <form id="userLoginForm">
                <div class="form-group">
                    <label for="loginEmail">Email:</label>
                    <input type="email" id="loginEmail" name="email" required>
                </div>
                
                <div class="form-group">
                    <label for="loginPassword">Password:</label>
                    <input type="password" id="loginPassword" name="password" required>
                </div>
                
                <button type="submit" class="btn">Login</button>
            </form>
        </div>
        
        <!-- Register Form -->
        <div id="registerForm" class="auth-form">
            <form id="userRegisterForm">
                <div class="form-group">
                    <label for="registerName">Full Name:</label>
                    <input type="text" id="registerName" name="name" required>
                </div>
                
                <div class="form-group">
                    <label for="registerEmail">Email:</label>
                    <input type="email" id="registerEmail" name="email" required>
                </div>
                
                <div class="form-group">
                    <label for="registerPassword">Password:</label>
                    <input type="password" id="registerPassword" name="password" required minlength="6">
                </div>
                
                <div class="form-group">
                    <label for="registerConfirmPassword">Confirm Password:</label>
                    <input type="password" id="registerConfirmPassword" name="confirmPassword" required minlength="6">
                </div>
                
                <div class="form-group">
                    <label for="userRole">Role:</label>
                    <select id="userRole" name="role" required>
                        <option value="">Select your role</option>
                        <option value="doctor">Doctor</option>
                        <option value="nurse">Nurse</option>
                        <option value="pharmacist">Pharmacist</option>
                        <option value="researcher">Researcher</option>
                        <option value="student">Student</option>
                        <option value="other">Other</option>
                    </select>
                </div>
                
                <button type="submit" class="btn">Create Account</button>
            </form>
        </div>
        
        <div class="error-message" id="authError">
            Invalid credentials. Please try again.
        </div>
        
        <div class="success-message" id="authSuccess">
            Account created successfully! You can now login.
        </div>
    </div>
    
    <!-- User Portal -->
    <div class="user-portal" id="userPortal">
        <div class="portal-header">
            <div class="welcome-text">
                <h2>Welcome, <span id="userName">User</span>!</h2>
                <p>Browse and access medical documents</p>
                
                <!-- Folder Assignment Info -->
                <div class="folder-assignment-info" id="folderAssignmentInfo" style="display: none;">
                    <div class="assignment-badge">
                        <span class="folder-icon">üìÅ</span>
                        <span class="assignment-text">
                            Your assigned folder: <strong id="assignedFolderName">-</strong>
                        </span>
                        <span class="assignment-order">#<span id="assignmentOrder">-</span></span>
                    </div>
                    <div class="assignment-details">
                        <small>Login time: <span id="loginTime">-</span> | Documents from folder <span id="folderRange">-</span></small>
                    </div>
                </div>
            </div>
            <button class="logout-btn" onclick="logout()">Logout</button>
        </div>
        
        <!-- Stats Section -->
        <div class="stats-section">
            <div class="stat-card">
                <div class="stat-number" id="totalDocsCount">0</div>
                <div class="stat-label">Total Documents</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="categoriesCount">0</div>
                <div class="stat-label">Categories</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="recentCount">0</div>
                <div class="stat-label">Recent Uploads</div>
            </div>
        </div>
        
        <!-- Search and Filter Section -->
        <div class="search-section">
            <h3>Find Documents</h3>
            <div class="search-controls">
                <div class="search-group">
                    <label for="searchQuery">Search:</label>
                    <input type="text" id="searchQuery" placeholder="Search documents...">
                </div>
                <div class="search-group">
                    <label for="filterCategory">Category:</label>
                    <select id="filterCategory">
                        <option value="">All Categories</option>
                        <option value="general">General</option>
                        <option value="medical">Medical Records</option>
                        <option value="reports">Reports</option>
                        <option value="policies">Policies</option>
                        <option value="training">Training Materials</option>
                        <option value="research">Research Documents</option>
                    </select>
                </div>
                <button class="search-btn" onclick="filterDocuments()">Search</button>
                <button class="search-btn btn-secondary" onclick="clearFilters()">Clear</button>
                <button class="search-btn" onclick="toggleView()" id="viewToggleBtn">üìÅ Folder View</button>
                <button class="search-btn" onclick="toggleView()" id="viewToggleBtn">üìÅ Folder View</button>
            </div>
        </div>
        
        <!-- Breadcrumb Navigation -->
        <div id="breadcrumb" class="breadcrumb" style="display: none;">
            <span onclick="navigateToFolder('')" class="breadcrumb-item">üìÅ Documents</span>
            <span id="breadcrumbPath"></span>
        </div>
        
        <!-- Breadcrumb Navigation -->
        <div id="breadcrumb" class="breadcrumb" style="display: none;">
            <span onclick="navigateToFolder('')" class="breadcrumb-item">üìÅ Documents</span>
            <span id="breadcrumbPath"></span>
        </div>
        
        <!-- Documents Grid -->
        <div id="documentsContainer">
            <h3>Available Documents</h3>
            <div class="documents-grid" id="documentsGrid">
                <!-- Documents will be loaded here -->
            </div>
        </div>
    </div>

    <!-- Add this HTML after the user portal div (around line 420): -->

    <!-- Document Viewer Modal -->
    <div class="document-viewer" id="documentViewer">
        <div class="viewer-content">
            <div class="viewer-header">
                <div class="viewer-title" id="viewerTitle">Document Viewer</div>
               <div class="viewer-toolbar">
                    <button class="annotation-btn btn-active" onclick="markAsActive()" id="activeBtn">
                        Mark as Active
                    </button>
                    <button class="annotation-btn btn-inactive" onclick="markAsInactive()" id="inactiveBtn">
                        Mark as Inactive
                    </button>
                    <button class="annotation-btn btn-clear" onclick="clearSelection()">
                        Clear Selection
                    </button>
                    <button class="annotation-btn" onclick="toggleAnnotationsPanel()" style="background: #17a2b8; color: white;">
                        Show Annotations (<span id="annotationCount">0</span>)
                    </button>
                    <button class="annotation-btn" onclick="saveAnnotations()" style="background: #28a745; color: white;">
                        Save
                    </button>
                    <button class="annotation-btn btn-close" onclick="closeViewer()">
                        Close
                    </button>
                </div>
            </div>
            <div class="viewer-body">
                <div class="document-content" id="documentContent">
                    <!-- Document content will be loaded here -->
                </div>
                <div class="selection-popup" id="selectionPopup">
                    <button class="btn-active" onclick="annotateSelection('active')">Active</button>
                    <button class="btn-inactive" onclick="annotateSelection('inactive')">Inactive</button>
                    <button class="btn-clear" onclick="hideSelectionPopup()">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Annotations Panel -->
    <div class="annotations-panel" id="annotationsPanel">
        <div class="annotations-header">
            <h4 style="margin: 0;">Document Annotations</h4>
            <button onclick="toggleAnnotationsPanel()" style="float: right; background: none; border: none; font-size: 1.2rem; cursor: pointer;">√ó</button>
        </div>
        <div class="annotations-list" id="annotationsList">
            <!-- Annotations will be listed here -->
        </div>
    </div>
    
    <script>
        // API Configuration
        const API_BASE_URL = 'https://rxnorm-portal-nscs.onrender.com';
        
        // User data storage
        let currentUser = null;
        let allDocuments = [];
        let filteredDocuments = [];
        
        // Authentication functions
        function showAuthTab(tabName, event = null) {
            // Update tab buttons
            document.querySelectorAll('.auth-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            if (event && event.target) {
                event.target.classList.add('active');
            } else {
                // Fallback: find the tab by tabName
                const targetTab = document.querySelector(`[onclick="showAuthTab('${tabName}')"]`);
                if (targetTab) {
                    targetTab.classList.add('active');
                }
            }
            
            if (event && event.target) {
                event.target.classList.add('active');
            } else {
                // Fallback: find the tab by tabName
                const targetTab = document.querySelector(`[onclick="showAuthTab('${tabName}')"]`);
                if (targetTab) {
                    targetTab.classList.add('active');
                }
            }
            
            // Show correct form
            document.querySelectorAll('.auth-form').forEach(form => {
                form.classList.remove('active');
            });
            document.getElementById(tabName + 'Form').classList.add('active');
            
            // Clear messages
            document.getElementById('authError').style.display = 'none';
            document.getElementById('authSuccess').style.display = 'none';
        }
        
        // Login form handler
        document.getElementById('userLoginForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            const email = document.getElementById('loginEmail').value;
            const password = document.getElementById('loginPassword').value;
            
            try {
                const response = await fetch(`${API_BASE_URL}/users/login`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        username: email, // Use email as username
                        password: password
                    })
                });
                
                const data = await response.json();
                
                if (data.success && data.user) {
                    currentUser = data.user;
                    
                    // Store folder assignment information
                    currentUser.assignedFolder = data.user.assigned_folder;
                    currentUser.assignmentOrder = data.user.assignment_order;
                    currentUser.loginTimestamp = data.user.login_timestamp;
                    currentUser.folderCount = data.user.folder_count;
                    
                    sessionStorage.setItem('currentUser', JSON.stringify(currentUser));
                    document.getElementById('authError').style.display = 'none';
                    
                    console.log(`üéØ User ${currentUser.name} assigned to folder: ${currentUser.assignedFolder} (Order: ${currentUser.assignmentOrder})`);
                    
                    showUserPortal();
                } else {
                    document.getElementById('authError').textContent = data.message || 'Invalid email or password.';
                    document.getElementById('authError').style.display = 'block';
                }
            } catch (error) {
                console.error('Login error:', error);
                document.getElementById('authError').textContent = 'Login failed. Please check your connection and try again.';
                document.getElementById('authError').style.display = 'block';
            }
        });
        
        // Register form handler
        document.getElementById('userRegisterForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            const name = document.getElementById('registerName').value;
            const email = document.getElementById('registerEmail').value;
            const password = document.getElementById('registerPassword').value;
            const confirmPassword = document.getElementById('registerConfirmPassword').value;
            const role = document.getElementById('userRole').value;
            
            // Validation
            if (password !== confirmPassword) {
                document.getElementById('authError').textContent = 'Passwords do not match.';
                document.getElementById('authError').style.display = 'block';
                return;
            }
            
            // Register user via API
            try {
                const response = await fetch(`${API_BASE_URL}/users/register`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        username: email, // Use email as username
                        email: email,
                        password: password,
                        name: name
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // Show success message and switch to login
                    document.getElementById('authSuccess').textContent = 'Registration successful! You can now log in.';
                    document.getElementById('authSuccess').style.display = 'block';
                    document.getElementById('authError').style.display = 'none';
                    
                    // Clear form
                    document.getElementById('userRegisterForm').reset();
                    
                    // Switch to login tab after 2 seconds
                    setTimeout(() => {
                        showAuthTab('login');
                        document.getElementById('loginEmail').value = email;
                    }, 2000);
                } else {
                    document.getElementById('authError').textContent = data.message || 'Registration failed. Please try again.';
                    document.getElementById('authError').style.display = 'block';
                    document.getElementById('authSuccess').style.display = 'none';
                }
            } catch (error) {
                console.error('Registration error:', error);
                document.getElementById('authError').textContent = 'Registration failed. Please check your connection and try again.';
                document.getElementById('authError').style.display = 'block';
                document.getElementById('authSuccess').style.display = 'none';
            }
            // Register user via API
            try {
                const response = await fetch(`${API_BASE_URL}/users/register`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        username: email, // Use email as username
                        email: email,
                        password: password,
                        name: name
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // Show success message and switch to login
                    document.getElementById('authSuccess').textContent = 'Registration successful! You can now log in.';
                    document.getElementById('authSuccess').style.display = 'block';
                    document.getElementById('authError').style.display = 'none';
                    
                    // Clear form
                    document.getElementById('userRegisterForm').reset();
                    
                    // Switch to login tab after 2 seconds
                    setTimeout(() => {
                        showAuthTab('login');
                        document.getElementById('loginEmail').value = email;
                    }, 2000);
                } else {
                    document.getElementById('authError').textContent = data.message || 'Registration failed. Please try again.';
                    document.getElementById('authError').style.display = 'block';
                    document.getElementById('authSuccess').style.display = 'none';
                }
            } catch (error) {
                console.error('Registration error:', error);
                document.getElementById('authError').textContent = 'Registration failed. Please check your connection and try again.';
                document.getElementById('authError').style.display = 'block';
                document.getElementById('authSuccess').style.display = 'none';
            }
        });
        
        function showUserPortal() {
            document.getElementById('authContainer').style.display = 'none';
            document.getElementById('userPortal').style.display = 'block';
            document.getElementById('userName').textContent = currentUser.name;
            
            // Display folder assignment information
            updateFolderAssignmentUI();
            
            // Ensure Azure configuration is available for new users
            ensureAzureConfigForUser();
            
            loadDocuments();
            updateStats();
        }
        
        // Update folder assignment UI
        function updateFolderAssignmentUI() {
            if (currentUser && currentUser.assignedFolder) {
                // Show folder assignment info
                document.getElementById('folderAssignmentInfo').style.display = 'block';
                document.getElementById('assignedFolderName').textContent = currentUser.assignedFolder;
                document.getElementById('assignmentOrder').textContent = currentUser.assignmentOrder || '-';
                document.getElementById('folderRange').textContent = currentUser.assignedFolder;
                
                // Format and display login time
                if (currentUser.loginTimestamp) {
                    const loginDate = new Date(currentUser.loginTimestamp);
                    const timeString = loginDate.toLocaleTimeString();
                    document.getElementById('loginTime').textContent = timeString;
                } else {
                    document.getElementById('loginTime').textContent = 'Just now';
                }
                
                console.log(`üìÅ UI Updated - User: ${currentUser.name}, Folder: ${currentUser.assignedFolder}, Order: ${currentUser.assignmentOrder}`);
            } else {
                document.getElementById('folderAssignmentInfo').style.display = 'none';
                console.warn('‚ö†Ô∏è No folder assignment found for user');
            }
        }
        
        // Ensure Azure configuration is available for the user
        async function ensureAzureConfigForUser() {
            // Check if user already has Azure config
            let userConfig = localStorage.getItem('azureConfigPublic') || localStorage.getItem('globalAzureConfig');
            
            if (!userConfig) {
                // Try to fetch from API server
                console.log('No local Azure configuration found. Attempting to fetch from API...');
                try {
                    const response = await fetch('https://rxnorm-portal-nscs.onrender.com/config/azure', {
                        method: 'GET',
                        headers: {
                            'Content-Type': 'application/json',
                        }
                    });
                    
                    console.log('API Response status:', response.status);
                    
                    if (response.ok) {
                        const data = await response.json();
                        console.log('API Response data:', data);
                        
                        if (data.success && data.config) {
                            // Store the fetched config locally
                            localStorage.setItem('globalAzureConfig', JSON.stringify(data.config));
                            console.log('Azure configuration fetched successfully from API');
                            hideConfigurationNotification();
                            
                            // Show success message
                            showSuccessNotification('‚úÖ Configuration loaded successfully! Documents should now be accessible.');
                            return;
                        } else {
                            console.log('API returned no configuration');
                            showErrorNotification('‚ùå No configuration found on server. Admin needs to configure Azure first.');
                        }
                    } else {
                        console.log('API request failed with status:', response.status);
                        showErrorNotification('‚ùå Failed to fetch configuration from server.');
                    }
                } catch (error) {
                    console.log('Failed to fetch Azure config from API:', error);
                    showErrorNotification('‚ùå Network error while fetching configuration.');
                }
                
                // If we still don't have config, show notification
                console.log('No Azure configuration available. Documents may not be accessible.');
                showConfigurationNotification();
            } else {
                console.log('Azure configuration found for user');
                hideConfigurationNotification();
            }
        }
        
        function showConfigurationNotification() {
            // Create or show notification banner
            let notification = document.getElementById('configNotification');
            if (!notification) {
                notification = document.createElement('div');
                notification.id = 'configNotification';
                notification.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    background: #f39c12;
                    color: white;
                    padding: 10px;
                    text-align: center;
                    z-index: 1000;
                    font-weight: bold;
                `;
                notification.innerHTML = `
                    ‚ö†Ô∏è Document access may be limited. Administrator needs to configure document sharing. 
                    <button onclick="retryConfigurationFetch()" style="margin-left: 10px; background: rgba(255,255,255,0.3); border: none; color: white; padding: 5px 10px; border-radius: 3px; cursor: pointer;">Retry</button>
                    <button onclick="hideConfigurationNotification()" style="margin-left: 5px; background: rgba(255,255,255,0.2); border: none; color: white; padding: 5px 10px; border-radius: 3px; cursor: pointer;">Dismiss</button>
                `;
                document.body.prepend(notification);
            }
            notification.style.display = 'block';
        }
        
        async function retryConfigurationFetch() {
            const notification = document.getElementById('configNotification');
            if (notification) {
                notification.innerHTML = `üîÑ Checking for configuration...`;
                notification.style.background = '#17a2b8'; // Blue for loading
            }
            
            await ensureAzureConfigForUser();
            
            // Reload documents if config was found
            const userConfig = localStorage.getItem('azureConfigPublic') || localStorage.getItem('globalAzureConfig');
            if (userConfig) {
                console.log('Config found, reloading documents...');
                await loadDocuments();
                updateStats();
            }
        }
        
        function showSuccessNotification(message) {
            const notification = document.getElementById('configNotification');
            if (notification) {
                notification.style.background = '#28a745';
                notification.innerHTML = message + ` <button onclick="hideConfigurationNotification()" style="margin-left: 10px; background: rgba(255,255,255,0.2); border: none; color: white; padding: 5px 10px; border-radius: 3px; cursor: pointer;">Dismiss</button>`;
                
                // Auto-hide after 3 seconds
                setTimeout(() => {
                    hideConfigurationNotification();
                }, 3000);
            }
        }
        
        function showErrorNotification(message) {
            const notification = document.getElementById('configNotification');
            if (notification) {
                notification.style.background = '#dc3545';
                notification.innerHTML = message + ` <button onclick="retryConfigurationFetch()" style="margin-left: 10px; background: rgba(255,255,255,0.3); border: none; color: white; padding: 5px 10px; border-radius: 3px; cursor: pointer;">Retry</button> <button onclick="hideConfigurationNotification()" style="margin-left: 5px; background: rgba(255,255,255,0.2); border: none; color: white; padding: 5px 10px; border-radius: 3px; cursor: pointer;">Dismiss</button>`;
            }
        }
        
        function hideConfigurationNotification() {
            const notification = document.getElementById('configNotification');
            if (notification) {
                notification.style.display = 'none';
            }
        }
        
        // Ensure Azure configuration is available for the user
        async function ensureAzureConfigForUser() {
            // Check if user already has Azure config
            let userConfig = localStorage.getItem('azureConfigPublic') || localStorage.getItem('globalAzureConfig');
            
            if (!userConfig) {
                // Try to fetch from API server
                console.log('No local Azure configuration found. Attempting to fetch from API...');
                try {
                    const response = await fetch('https://rxnorm-portal-nscs.onrender.com/config/azure', {
                        method: 'GET',
                        headers: {
                            'Content-Type': 'application/json',
                        }
                    });
                    
                    console.log('API Response status:', response.status);
                    
                    if (response.ok) {
                        const data = await response.json();
                        console.log('API Response data:', data);
                        
                        if (data.success && data.config) {
                            // Store the fetched config locally
                            localStorage.setItem('globalAzureConfig', JSON.stringify(data.config));
                            console.log('Azure configuration fetched successfully from API');
                            hideConfigurationNotification();
                            
                            // Show success message
                            showSuccessNotification('‚úÖ Configuration loaded successfully! Documents should now be accessible.');
                            return;
                        } else {
                            console.log('API returned no configuration');
                            showErrorNotification('‚ùå No configuration found on server. Admin needs to configure Azure first.');
                        }
                    } else {
                        console.log('API request failed with status:', response.status);
                        showErrorNotification('‚ùå Failed to fetch configuration from server.');
                    }
                } catch (error) {
                    console.log('Failed to fetch Azure config from API:', error);
                    showErrorNotification('‚ùå Network error while fetching configuration.');
                }
                
                // If we still don't have config, show notification
                console.log('No Azure configuration available. Documents may not be accessible.');
                showConfigurationNotification();
            } else {
                console.log('Azure configuration found for user');
                hideConfigurationNotification();
            }
        }
        
        function showConfigurationNotification() {
            // Create or show notification banner
            let notification = document.getElementById('configNotification');
            if (!notification) {
                notification = document.createElement('div');
                notification.id = 'configNotification';
                notification.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    background: #f39c12;
                    color: white;
                    padding: 10px;
                    text-align: center;
                    z-index: 1000;
                    font-weight: bold;
                `;
                notification.innerHTML = `
                    ‚ö†Ô∏è Document access may be limited. Administrator needs to configure document sharing. 
                    <button onclick="retryConfigurationFetch()" style="margin-left: 10px; background: rgba(255,255,255,0.3); border: none; color: white; padding: 5px 10px; border-radius: 3px; cursor: pointer;">Retry</button>
                    <button onclick="hideConfigurationNotification()" style="margin-left: 5px; background: rgba(255,255,255,0.2); border: none; color: white; padding: 5px 10px; border-radius: 3px; cursor: pointer;">Dismiss</button>
                `;
                document.body.prepend(notification);
            }
            notification.style.display = 'block';
        }
        
        async function retryConfigurationFetch() {
            const notification = document.getElementById('configNotification');
            if (notification) {
                notification.innerHTML = `üîÑ Checking for configuration...`;
                notification.style.background = '#17a2b8'; // Blue for loading
            }
            
            await ensureAzureConfigForUser();
            
            // Reload documents if config was found
            const userConfig = localStorage.getItem('azureConfigPublic') || localStorage.getItem('globalAzureConfig');
            if (userConfig) {
                console.log('Config found, reloading documents...');
                await loadDocuments();
                updateStats();
            }
        }
        
        function showSuccessNotification(message) {
            const notification = document.getElementById('configNotification');
            if (notification) {
                notification.style.background = '#28a745';
                notification.innerHTML = message + ` <button onclick="hideConfigurationNotification()" style="margin-left: 10px; background: rgba(255,255,255,0.2); border: none; color: white; padding: 5px 10px; border-radius: 3px; cursor: pointer;">Dismiss</button>`;
                
                // Auto-hide after 3 seconds
                setTimeout(() => {
                    hideConfigurationNotification();
                }, 3000);
            }
        }
        
        function showErrorNotification(message) {
            const notification = document.getElementById('configNotification');
            if (notification) {
                notification.style.background = '#dc3545';
                notification.innerHTML = message + ` <button onclick="retryConfigurationFetch()" style="margin-left: 10px; background: rgba(255,255,255,0.3); border: none; color: white; padding: 5px 10px; border-radius: 3px; cursor: pointer;">Retry</button> <button onclick="hideConfigurationNotification()" style="margin-left: 5px; background: rgba(255,255,255,0.2); border: none; color: white; padding: 5px 10px; border-radius: 3px; cursor: pointer;">Dismiss</button>`;
            }
        }
        
        function hideConfigurationNotification() {
            const notification = document.getElementById('configNotification');
            if (notification) {
                notification.style.display = 'none';
            }
        }
        
        function logout() {
            currentUser = null;
            sessionStorage.removeItem('currentUser');
            
            document.getElementById('authContainer').style.display = 'block';
            document.getElementById('userPortal').style.display = 'none';
            
            // Clear forms
            document.getElementById('userLoginForm').reset();
            document.getElementById('authError').style.display = 'none';
            document.getElementById('authSuccess').style.display = 'none';
        }
        
        // Document functions
        let currentView = 'grid'; // 'grid' or 'folder'
        let currentFolder = ''; // Current folder path
        
        async function loadDocuments() {
            try {
                // Check if user has an assigned folder
                const userAssignedFolder = currentUser?.assigned_folder;
                console.log('üéØ Debug - Current user:', currentUser);
                console.log('üéØ Debug - User assigned folder:', userAssignedFolder);
                
                // Load documents from localStorage (admin uploaded)
                const localDocuments = JSON.parse(localStorage.getItem('documentsData')) || [];
                console.log(`Found ${localDocuments.length} documents in localStorage`);
                
                // Create consistent ID function
                const createDocumentId = (blobName, filename, originalPath) => {
                    // Use blob name for Azure documents, original path for localStorage documents, or filename as fallback
                    const base = blobName || originalPath || filename;
                    // Simple hash function to create consistent IDs
                    let hash = 0;
                    for (let i = 0; i < base.length; i++) {
                        const char = base.charCodeAt(i);
                        hash = ((hash << 5) - hash) + char;
                        hash = hash & hash; // Convert to 32-bit integer
                    }
                    return Math.abs(hash);
                };
                
                // Migrate localStorage documents to use consistent IDs
                let documentsUpdated = false;
                for (const doc of localDocuments) {
                    const newId = createDocumentId(doc.blobName, doc.name, doc.originalPath);
                    if (doc.id !== newId) {
                        console.log(`üìù Migrating document ID: ${doc.name} from ${doc.id} to ${newId}`);
                        doc.id = newId;
                        documentsUpdated = true;
                    }
                }
                
                // Save updated localStorage documents if IDs were changed
                if (documentsUpdated) {
                    localStorage.setItem('documentsData', JSON.stringify(localDocuments));
                    console.log('‚úÖ Updated localStorage with consistent document IDs');
                }
                
                // Always try to fetch from Azure as well to merge both sources
                console.log('Attempting to fetch from Azure...');
                
                const azureConfigData = localStorage.getItem('azureConfigPublic') || localStorage.getItem('globalAzureConfig');
                if (!azureConfigData) {
                    console.log('No Azure configuration available - using only localStorage documents');
                    // Filter localStorage documents by user's assigned folder if they have one
                    if (userAssignedFolder) {
                        allDocuments = localDocuments.filter(doc => 
                            doc.category === userAssignedFolder || 
                            doc.blobName?.includes(userAssignedFolder) ||
                            doc.folderPath === userAssignedFolder
                        );
                        console.log(`üéØ User ${currentUser.name} assigned to folder '${userAssignedFolder}' - Showing ${allDocuments.length} documents from localStorage`);
                    } else {
                        allDocuments = localDocuments;
                        console.log(`Loaded ${allDocuments.length} documents from localStorage for user: ${currentUser.name} (no folder restriction)`);
                    }
                    filteredDocuments = [...allDocuments];
                    displayDocuments();
                    return;
                }
                
                const azureConfig = JSON.parse(azureConfigData);
                console.log('Using Azure config:', azureConfig);
                
                // Clean the SAS token
                let sasToken = azureConfig.sasToken;
                if (sasToken.startsWith('?')) {
                    sasToken = sasToken.substring(1); // Remove leading ?
                }
                
                // Parse existing SAS parameters
                const sasParams = new URLSearchParams(sasToken);
                
                // Ensure we have the correct permissions for container listing
                if (!sasParams.has('sr')) {
                    sasParams.set('sr', 'c'); // Container resource
                }
                
                // Ensure we have list permission
                const sp = sasParams.get('sp') || '';
                if (!sp.includes('l')) {
                    sasParams.set('sp', sp + 'l'); // Add list permission
                }
                
                // Create a separate SAS token for blob access with read permissions
                const blobSasParams = new URLSearchParams(sasToken);
                blobSasParams.set('sr', 'b'); // Blob resource (instead of container)
                const blobSp = blobSasParams.get('sp') || '';
                if (!blobSp.includes('r')) {
                    blobSasParams.set('sp', blobSp + 'r'); // Add read permission for blobs
                }
                const blobSasToken = blobSasParams.toString();
                
                // Construct the final URL
                const listUrl = `https://${azureConfig.storageAccount}.blob.core.windows.net/${azureConfig.containerName}?restype=container&comp=list&${sasParams.toString()}`;
                console.log('Fetching from Azure URL:', listUrl);
                
                const response = await fetch(listUrl);
                console.log('Azure response status:', response.status);
                
                if (response.ok) {
                    const xmlText = await response.text();
                    console.log('Azure XML response length:', xmlText.length);
                    console.log('Azure XML response (first 500 chars):', xmlText.substring(0, 500));
                    
                    // Parse the XML response to extract blob names
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
                    const blobs = xmlDoc.getElementsByTagName('Blob');
                    console.log('Found blobs:', blobs.length);
                    
                    const documents = [];
                    for (let i = 0; i < blobs.length; i++) {
                        const blob = blobs[i];
                        const name = blob.getElementsByTagName('Name')[0]?.textContent;
                        const lastModified = blob.getElementsByTagName('Last-Modified')[0]?.textContent;
                        const size = blob.getElementsByTagName('Content-Length')[0]?.textContent;
                        
                        console.log(`Blob ${i}:`, { name, lastModified, size });
                        
                        if (name && name.endsWith('.html')) {
                            // Parse folder structure from blob name
                            const pathParts = name.split('/');
                            const filename = pathParts[pathParts.length - 1];
                            const category = pathParts[0] || 'general';
                            const folderName = pathParts.length > 2 ? pathParts[1] : null;
                            const isFromFolder = pathParts.length > 2;
                            
                            // Create proper originalPath for folder structure
                            const originalPath = isFromFolder ? pathParts.slice(1).join('/') : filename;
                            
                            documents.push({
                                id: createDocumentId(name, filename, originalPath),
                                name: filename,
                                originalPath: originalPath,
                                folderName: folderName,
                                category: category,
                                description: 'Document from Azure Storage',
                                publicAccess: true,
                                uploadDate: lastModified ? new Date(lastModified).toISOString().split('T')[0] : new Date().toISOString().split('T')[0],
                                size: formatFileSize(parseInt(size) || 0),
                                azureUrl: `https://${azureConfig.storageAccount}.blob.core.windows.net/${azureConfig.containerName}/${name}?${blobSasToken}`,
                                blobName: name,
                                isFromFolder: isFromFolder,
                                hasPreAnnotations: false,
                                preAnnotations: [] // Will be loaded when document is opened
                            });
                        }
                    }
                    
                    console.log(`Created ${documents.length} document objects from Azure blobs`);
                    
                    // Debug: Log first few documents to see their structure
                    console.log('üîç Sample Azure documents:', documents.slice(0, 3).map(doc => ({
                        name: doc.name,
                        category: doc.category,
                        blobName: doc.blobName,
                        originalPath: doc.originalPath
                    })));
                    
                    // Merge Azure documents with localStorage documents
                    const allAvailableDocuments = [...localDocuments];
                    
                    // Add Azure documents that aren't already in localStorage
                    for (const azureDoc of documents) {
                        const existsInLocal = localDocuments.some(localDoc => 
                            localDoc.blobName === azureDoc.blobName || 
                            localDoc.name === azureDoc.name
                        );
                        if (!existsInLocal) {
                            allAvailableDocuments.push(azureDoc);
                        }
                    }
                    
                    console.log(`Total merged documents: ${allAvailableDocuments.length} (${localDocuments.length} from localStorage + ${documents.length - (allAvailableDocuments.length - localDocuments.length)} new from Azure)`);
                    
                    // Filter documents by user's assigned folder if they have one
                    if (userAssignedFolder) {
                        console.log(`üîç Before filtering: ${allAvailableDocuments.length} total documents`);
                        console.log('üîç Sample categories in documents:', [...new Set(allAvailableDocuments.map(doc => doc.category))].slice(0, 10));
                        
                        allDocuments = allAvailableDocuments.filter(doc => {
                            const matches = doc.category === userAssignedFolder || 
                                          doc.blobName?.includes(userAssignedFolder) ||
                                          doc.folderPath === userAssignedFolder;
                            if (matches) {
                                console.log(`‚úÖ Document matches: ${doc.name} (category: ${doc.category})`);
                            }
                            return matches;
                        });
                        console.log(`üéØ Filtered merged documents - User ${currentUser.name} assigned to folder '${userAssignedFolder}' - Showing ${allDocuments.length}/${allAvailableDocuments.length} documents from assigned folder`);
                    } else {
                        allDocuments = allAvailableDocuments;
                        console.log(`Loaded ${allDocuments.length} merged documents for user: ${currentUser.name} (no folder restriction)`);
                    }
                    
                    filteredDocuments = [...allDocuments];
                    
                    // Debug: Show what documents we have
                    console.log('All documents after filtering:', allDocuments);
                } else {
                    const errorText = await response.text();
                    console.log('Failed to fetch document list from Azure:', response.status, errorText);
                    console.log('Using only localStorage documents due to Azure error');
                    
                    // Filter localStorage documents by user's assigned folder if they have one
                    if (userAssignedFolder) {
                        allDocuments = localDocuments.filter(doc => 
                            doc.category === userAssignedFolder || 
                            doc.blobName?.includes(userAssignedFolder) ||
                            doc.folderPath === userAssignedFolder
                        );
                        console.log(`üéØ User ${currentUser.name} assigned to folder '${userAssignedFolder}' - Showing ${allDocuments.length} documents from localStorage (Azure failed)`);
                    } else {
                        allDocuments = localDocuments;
                        console.log(`Loaded ${allDocuments.length} documents from localStorage for user: ${currentUser.name} (Azure failed)`);
                    }
                    filteredDocuments = [...allDocuments];
                }
                
            } catch (error) {
                console.log('Error loading documents:', error);
                console.log('Using only localStorage documents due to error');
                
                // Load documents from localStorage as fallback
                const localDocuments = JSON.parse(localStorage.getItem('documentsData')) || [];
                
                // Filter localStorage documents by user's assigned folder if they have one
                const userAssignedFolder = currentUser?.assigned_folder;
                if (userAssignedFolder) {
                    allDocuments = localDocuments.filter(doc => 
                        doc.category === userAssignedFolder || 
                        doc.blobName?.includes(userAssignedFolder) ||
                        doc.folderPath === userAssignedFolder
                    );
                    console.log(`üéØ User ${currentUser.name} assigned to folder '${userAssignedFolder}' - Showing ${allDocuments.length} documents from localStorage (error fallback)`);
                } else {
                    allDocuments = localDocuments;
                    console.log(`Loaded ${allDocuments.length} documents from localStorage for user: ${currentUser.name} (error fallback)`);
                }
                filteredDocuments = [...allDocuments];
            }
            
            displayDocuments();
        }
        
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        function toggleView() {
            const toggleBtn = document.getElementById('viewToggleBtn');
            const breadcrumb = document.getElementById('breadcrumb');
            
            if (currentView === 'grid') {
                currentView = 'folder';
                toggleBtn.textContent = 'üìÑ List View';
                breadcrumb.style.display = 'block';
                navigateToFolder('');
            } else {
                currentView = 'grid';
                toggleBtn.textContent = 'üìÅ Folder View';
                breadcrumb.style.display = 'none';
                displayDocuments();
            }
        }
        
        function navigateToFolder(folderPath) {
            currentFolder = folderPath;
            updateBreadcrumb();
            
            if (currentView === 'folder') {
                displayFolderView();
            }
        }
        
        function updateBreadcrumb() {
            const breadcrumbPath = document.getElementById('breadcrumbPath');
            
            if (currentFolder === '') {
                breadcrumbPath.innerHTML = '';
                return;
            }
            
            const pathParts = currentFolder.split('/').filter(part => part);
            let html = '';
            let currentPath = '';
            
            pathParts.forEach((part, index) => {
                currentPath += (currentPath ? '/' : '') + part;
                html += `<span class="breadcrumb-separator">></span>`;
                html += `<span onclick="navigateToFolder('${currentPath}')" class="breadcrumb-item">üìÅ ${part}</span>`;
            });
            
            breadcrumbPath.innerHTML = html;
        }
        
        function displayFolderView() {
            const documentsGrid = document.getElementById('documentsGrid');
            
            // Get unique folders and files for current path
            const foldersAndFiles = getFoldersAndFiles(currentFolder);
            
            if (foldersAndFiles.folders.length === 0 && foldersAndFiles.files.length === 0) {
                documentsGrid.innerHTML = `
                    <div class="no-documents">
                        <h3>Empty Folder</h3>
                        <p>This folder contains no documents or subfolders.</p>
                        <button class="btn btn-primary" onclick="navigateToFolder('')">Back to Root</button>
                    </div>
                `;
                return;
            }
            
            let html = '';
            
            // Display folders first
            foldersAndFiles.folders.forEach(folder => {
                const folderName = folder.name;
                const folderPath = currentFolder ? `${currentFolder}/${folderName}` : folderName;
                const fileCount = folder.fileCount;
                
                html += `
                    <div class="folder-card" onclick="navigateToFolder('${folderPath}')">
                        <div class="folder-badge">${fileCount} files</div>
                        <div class="folder-icon">üìÅ</div>
                        <div class="folder-title">${folderName}</div>
                        <div class="folder-meta">
                            Category: ${folder.category}<br>
                            ${fileCount} file(s)
                        </div>
                    </div>
                `;
            });
            
            // Display files in current folder
            foldersAndFiles.files.forEach(doc => {
                const icon = getDocumentIcon(doc.name);
                const badgeClass = `badge-${doc.category}`;
                
                html += `
                    <div class="document-card" onclick="viewDocument('${doc.id}')">
                        <div class="document-icon">${icon}</div>
                        <div class="category-badge ${badgeClass}">${doc.category.toUpperCase()}</div>
                        <div class="document-title">${doc.name}</div>
                        <div class="document-meta">
                            Uploaded: ${doc.uploadDate}<br>
                            Size: ${doc.size}
                        </div>
                        ${doc.description ? `<div class="document-description">${doc.description}</div>` : ''}
                        <div class="document-actions">
                            <button class="btn-small btn-view" onclick="event.stopPropagation(); viewDocument('${doc.id}')">View</button>
                            <button class="btn-small btn-download" onclick="event.stopPropagation(); downloadDocument('${doc.id}')">Download</button>
                        </div>
                    </div>
                `;
            });
            
            documentsGrid.innerHTML = html;
        }
        
        function getFoldersAndFiles(currentPath) {
            const folders = new Map();
            const files = [];
            
            filteredDocuments.forEach(doc => {
                if (!doc.originalPath || !doc.isFromFolder) {
                    // Individual files (not from folder uploads) - show in root
                    if (currentPath === '') {
                        files.push(doc);
                    }
                    return;
                }
                
                // Parse the folder structure from originalPath
                const relativePath = doc.originalPath;
                const pathParts = relativePath.split('/').filter(part => part);
                
                if (pathParts.length === 0) return;
                
                // Check if this file belongs to the current path
                const currentPathParts = currentPath ? currentPath.split('/').filter(part => part) : [];
                
                // Check if the file is in a subfolder of current path
                if (pathParts.length > currentPathParts.length) {
                    let isInCurrentPath = true;
                    for (let i = 0; i < currentPathParts.length; i++) {
                        if (pathParts[i] !== currentPathParts[i]) {
                            isInCurrentPath = false;
                            break;
                        }
                    }
                    
                    if (isInCurrentPath) {
                        if (pathParts.length === currentPathParts.length + 1) {
                            // File is directly in current folder
                            files.push(doc);
                        } else {
                            // File is in a subfolder
                            const subfolderName = pathParts[currentPathParts.length];
                            const subfolderPath = [...currentPathParts, subfolderName].join('/');
                            
                            if (!folders.has(subfolderName)) {
                                folders.set(subfolderName, {
                                    name: subfolderName,
                                    path: subfolderPath,
                                    fileCount: 0,
                                    category: doc.category
                                });
                            }
                            folders.get(subfolderName).fileCount++;
                        }
                    }
                }
            });
            
            return {
                folders: Array.from(folders.values()),
                files: files
            };
        }
        
        function displayDocuments() {
            if (currentView === 'folder') {
                displayFolderView();
                return;
            }
            
            if (currentView === 'folder') {
                displayFolderView();
                return;
            }
            
            const documentsGrid = document.getElementById('documentsGrid');
            
            if (filteredDocuments.length === 0) {
                documentsGrid.innerHTML = `
                    <div class="no-documents">
                        <h3>No Documents Found</h3>
                        <p>No documents are currently available or match your search criteria.</p>
                    </div>
                `;
                return;
            }
            
            let html = '';
            filteredDocuments.forEach(doc => {
                const icon = getDocumentIcon(doc.name);
                const badgeClass = `badge-${doc.category}`;
                
                // Add folder indicator for files from folder uploads
                const folderIndicator = doc.isFromFolder ? '<span style="color: #6f42c1;">üìÅ</span> ' : '';
                
                html += `
                    <div class="document-card" onclick="viewDocument('${doc.id}')">
                        <div class="document-icon">${icon}</div>
                        <div class="category-badge ${badgeClass}">${doc.category.toUpperCase()}</div>
                        <div class="document-title">${folderIndicator}${doc.name}</div>
                        <div class="document-title">${folderIndicator}${doc.name}</div>
                        <div class="document-meta">
                            Uploaded: ${doc.uploadDate}<br>
                            Size: ${doc.size}
                            ${doc.originalPath && doc.originalPath !== doc.name ? `<br><small>üìÇ ${doc.originalPath}</small>` : ''}
                            ${doc.originalPath && doc.originalPath !== doc.name ? `<br><small>üìÇ ${doc.originalPath}</small>` : ''}
                        </div>
                        ${doc.description ? `<div class="document-description">${doc.description}</div>` : ''}
                        <div class="document-actions">
                            <button class="btn-small btn-view" onclick="event.stopPropagation(); viewDocument('${doc.id}')">View</button>
                            <button class="btn-small btn-download" onclick="event.stopPropagation(); downloadDocument('${doc.id}')">Download</button>
                        </div>
                    </div>
                `;
            });
            
            documentsGrid.innerHTML = html;
        }
        
        function getDocumentIcon(filename) {
            const ext = filename.split('.').pop().toLowerCase();
            const icons = {
                'pdf': 'üìÑ',
                'doc': 'üìù',
                'docx': 'üìù',
                'html': 'üåê',
                'htm': 'üåê',
                'txt': 'üìÑ',
                'jpg': 'üñºÔ∏è',
                'jpeg': 'üñºÔ∏è',
                'png': 'üñºÔ∏è',
                'xlsx': 'üìä',
                'pptx': 'üìΩÔ∏è'
            };
            return icons[ext] || 'üìÅ';
        }
        
        function filterDocuments() {
            const searchQuery = document.getElementById('searchQuery').value.toLowerCase();
            const categoryFilter = document.getElementById('filterCategory').value;
            
            filteredDocuments = allDocuments.filter(doc => {
                const matchesSearch = !searchQuery || 
                    doc.name.toLowerCase().includes(searchQuery) || 
                    (doc.description && doc.description.toLowerCase().includes(searchQuery));
                
                const matchesCategory = !categoryFilter || doc.category === categoryFilter;
                
                return matchesSearch && matchesCategory;
            });
            
            displayDocuments();
        }
        
        function clearFilters() {
            document.getElementById('searchQuery').value = '';
            document.getElementById('filterCategory').value = '';
            filteredDocuments = [...allDocuments];
            displayDocuments();
        }
        
        
        function downloadDocument(docId) {
            const doc = allDocuments.find(d => d.id == docId);
            if (doc) {
                // In production, this would trigger download from Azure
                alert(`Downloading: ${doc.name}\nAzure URL: ${doc.azureUrl}`);
            }
        }
        
        function updateStats() {
            document.getElementById('totalDocsCount').textContent = allDocuments.length;
            
            const categories = [...new Set(allDocuments.map(doc => doc.category))];
            document.getElementById('categoriesCount').textContent = categories.length;
            
            // Recent uploads (last 30 days)
            const thirtyDaysAgo = new Date();
            thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
            const recentDocs = allDocuments.filter(doc => 
                new Date(doc.uploadDate) > thirtyDaysAgo
            );
            document.getElementById('recentCount').textContent = recentDocs.length;
        }
        
        // Search on Enter key
        document.getElementById('searchQuery').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                filterDocuments();
            }
        });
        
        // Check if user is already logged in
        window.addEventListener('load', function() {
            const savedUser = sessionStorage.getItem('currentUser');
            if (savedUser) {
                currentUser = JSON.parse(savedUser);
                showUserPortal();
            }
        });
    </script>

    <script>
        // Annotation functionality
        let currentDocument = null;
        let documentAnnotations = [];
        let currentAnnotationMode = 'active';
        let selectedRange = null;

        // Update the viewDocument function
        function viewDocument(docId) {
            const doc = allDocuments.find(d => d.id == docId);
            if (doc) {
                currentDocument = doc;
                openDocumentViewer(doc);
            }
        }

        // Replace the openDocumentViewer function (around line 1120) with this:
        async function openDocumentViewer(doc) {
            document.getElementById('documentViewer').style.display = 'block';
            document.getElementById('viewerTitle').textContent = doc.name;
            
            // Reset annotation count and list for new document
            const countElement = document.getElementById('annotationCount');
            if (countElement) {
                countElement.textContent = '0';
            }
            
            try {
                // Load document content
                const content = await loadDocumentContent(doc);
                document.getElementById('documentContent').innerHTML = content;
                
                // Important: Wait a bit for content to render, then load annotations
                setTimeout(() => {
                    loadDocumentAnnotations(doc.id);
                    // Note: updateAnnotationCount() and updateAnnotationsList() are called within loadDocumentAnnotations
                }, 100);
                
            } catch (error) {
                console.error('Error loading document:', error);
                document.getElementById('documentContent').innerHTML = `
                    <div style="text-align: center; padding: 2rem; color: #666;">
                        <h3>Unable to load document content</h3>
                        <p>This document format cannot be displayed for annotation.</p>
                        <p><strong>Document:</strong> ${doc.name}</p>
                        <p><strong>Size:</strong> ${doc.size}</p>
                        <button onclick="window.open('${doc.azureUrl}', '_blank')" class="annotation-btn" style="background: #667eea; color: white;">
                            Open Original Document
                        </button>
                    </div>
                `;
            }
        }

       // Replace the loadDocumentContent function (lines 1139-1212) with this:
        async function loadDocumentContent(doc) {
            const fileExtension = doc.name.split('.').pop().toLowerCase();
            
            if (fileExtension === 'html' || fileExtension === 'htm') {
                try {
                    // Get Azure config from localStorage
                    const adminConfigData = localStorage.getItem('azureConfigPublic') || localStorage.getItem('globalAzureConfig') || localStorage.getItem('azureConfig');
                    
                    if (!adminConfigData) {
                        throw new Error('Azure configuration not found. Please contact administrator to configure Azure access.');
                    }
                    
                    const adminConfig = JSON.parse(adminConfigData);
                    
                    if (!adminConfig.sasToken || !adminConfig.storageAccount || !adminConfig.containerName) {
                        throw new Error('Incomplete Azure configuration. Please contact administrator.');
                    }
                    
                    // Construct the Azure blob URL with SAS token
                    const blobUrl = `https://${adminConfig.storageAccount}.blob.core.windows.net/${adminConfig.containerName}/${doc.blobName}${adminConfig.sasToken}`;
                    
                    console.log('Fetching document from:', blobUrl);
                    
                    // Fetch the actual HTML content from Azure
                    const response = await fetch(blobUrl, {
                        method: 'GET',
                        headers: {
                            'Cache-Control': 'no-cache'
                        }
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Failed to fetch document: ${response.status} ${response.statusText}`);
                    }
                    
                    // Get the HTML content
                    const htmlContent = await response.text();
                    
                    console.log('Document content loaded successfully');
                    
                    // Extract only the body content to avoid nested HTML structure
                    const parser = new DOMParser();
                    const parsedDoc = parser.parseFromString(htmlContent, 'text/html');
                    
                    // Get the body content, or fall back to the entire content if no body tag
                    const bodyContent = parsedDoc.body ? parsedDoc.body.innerHTML : htmlContent;
                    
                    // Return the extracted content wrapped in a div for proper annotation handling
                    return `<div class="document-body-content">${bodyContent}</div>`;
                    
                } catch (error) {
                    console.error('Error fetching document from Azure:', error);
                    
                    // Fallback to showing error message with link to original
                    return `
                        <div style="text-align: center; padding: 2rem; color: #666;">
                            <h3>Unable to load document content</h3>
                            <p><strong>Error:</strong> ${error.message}</p>
                            <p><strong>Document:</strong> ${doc.name}</p>
                            <p><strong>Size:</strong> ${doc.size}</p>
                            <button onclick="window.open('${doc.azureUrl}', '_blank')" class="annotation-btn" style="background: #667eea; color: white;">
                                Open Original Document in New Tab
                            </button>
                        </div>
                    `;
                }
            } else {
                // For non-HTML files, show a preview message
                return `
                    <div style="text-align: center; padding: 2rem;">
                        <h3>Document Preview: ${doc.name}</h3>
                        <p>This is a ${fileExtension.toUpperCase()} file. Annotation is currently only supported for HTML documents.</p>
                        <p>You can view the original document by clicking the button below.</p>
                        <br>
                        <button onclick="window.open('${doc.azureUrl}', '_blank')" class="annotation-btn" style="background: #667eea; color: white;">
                            Open Original Document
                        </button>
                    </div>
                `;
            }
        }

        // Function to load pre-annotations from processed document data
        async function loadPreAnnotations(doc) {
            try {
                console.log('üîçüÜï [V3-' + new Date().getTime() + '] Loading pre-annotations for:', doc.name);
                
                // Check if document already has pre-annotations from admin processing
                if (doc.preAnnotations && Array.isArray(doc.preAnnotations) && doc.preAnnotations.length > 0) {
                    console.log(`ü§ñ Found ${doc.preAnnotations.length} pre-annotations from admin processing`);
                    doc.hasPreAnnotations = true;
                    return doc.preAnnotations;
                }
                
                // If no pre-annotations in document object, check localStorage for updated documents data
                const localDocuments = JSON.parse(localStorage.getItem('documentsData')) || [];
                const localDoc = localDocuments.find(d => d.id === doc.id || d.name === doc.name);
                
                if (localDoc && localDoc.preAnnotations && Array.isArray(localDoc.preAnnotations) && localDoc.preAnnotations.length > 0) {
                    console.log(`ü§ñ Found ${localDoc.preAnnotations.length} pre-annotations from localStorage`);
                    doc.preAnnotations = localDoc.preAnnotations;
                    doc.hasPreAnnotations = true;
                    return localDoc.preAnnotations;
                }
                
                // If no pre-annotations found, generate them using main.py API
                console.log('üöÄüÜï [V3] No pre-annotations found, generating new ones via main.py API...');
                const generatedAnnotations = await generatePreAnnotationsFromAPI(doc);
                
                if (generatedAnnotations && generatedAnnotations.length > 0) {
                    console.log(`‚ú® Generated ${generatedAnnotations.length} new pre-annotations via API`);
                    doc.preAnnotations = generatedAnnotations;
                    doc.hasPreAnnotations = true;
                    return generatedAnnotations;
                }
                
                console.log('‚ÑπÔ∏è No medications found in this document');
                doc.preAnnotations = [];
                doc.hasPreAnnotations = false;
                return [];
                
            } catch (error) {
                console.warn('‚ö†Ô∏è Failed to load pre-annotations:', error);
                doc.preAnnotations = [];
                doc.hasPreAnnotations = false;
                return [];
            }
        }
        
        // Function to generate pre-annotations by calling main.py API
        async function generatePreAnnotationsFromAPI(doc) {
            // Show progress notification
            showProcessingNotification(`ü§ñ Analyzing ${doc.name} for medications...`);
            
            try {
                console.log('üîÑüÜï [V3] Calling main.py API to process document:', doc.name);
                
                // Get document content from Azure
                const azureConfigData = localStorage.getItem('azureConfigPublic') || localStorage.getItem('globalAzureConfig') || localStorage.getItem('azureConfig');
                if (!azureConfigData) {
                    throw new Error('No Azure configuration found');
                }
                
                const azureConfig = JSON.parse(azureConfigData);
                // doc.azureUrl already includes the SAS token, so use it directly
                const documentUrl = doc.azureUrl;
                
                // First, fetch the document content
                console.log('üìÑ Fetching document content from:', documentUrl);
                console.log('üîê Document URL SAS token permissions check:', documentUrl.includes('sp=') ? documentUrl.match(/sp=([^&]*)/)?.[1] : 'No sp parameter found');
                updateProcessingNotification('üìÑ Downloading document content...');
                
                const docResponse = await fetch(documentUrl);
                console.log('üìÑ Document fetch response status:', docResponse.status);
                console.log('üìÑ Document fetch response headers:', [...docResponse.headers.entries()]);
                
                if (!docResponse.ok) {
                    const errorText = await docResponse.text();
                    console.error('üìÑ Document fetch error details:', errorText);
                    throw new Error(`Failed to fetch document: ${docResponse.status} - ${errorText}`);
                }
                
                const docBlob = await docResponse.blob();
                
                // Create FormData to send to main.py API
                const formData = new FormData();
                formData.append('file', docBlob, doc.name);
                
                console.log('ü§ñ Sending document to main.py for processing...');
                updateProcessingNotification('ü§ñ Processing with AI medication extraction...');
                
                const apiResponse = await fetch(`${API_BASE_URL}/process-document`, {
                    method: 'POST',
                    body: formData
                });
                
                if (!apiResponse.ok) {
                    const errorText = await apiResponse.text();
                    throw new Error(`API processing failed: ${apiResponse.status} ${apiResponse.statusText} - ${errorText}`);
                }
                
                const result = await apiResponse.json();
                console.log('üìä API processing result:', result);
                
                hideProcessingNotification();
                
                if (result.success && result.annotations && Array.isArray(result.annotations)) {
                    console.log(`‚úÖ Successfully generated ${result.annotations.length} annotations`);
                    showSuccessNotification(`‚ú® Found ${result.annotations.length} medications in ${doc.name}`);
                    return result.annotations;
                } else {
                    console.log('‚ÑπÔ∏è API processing completed but no annotations found');
                    showSuccessNotification(`‚ÑπÔ∏è No medications found in ${doc.name}`);
                    return [];
                }
                
            } catch (error) {
                console.error('‚ùå Failed to generate pre-annotations from API:', error);
                hideProcessingNotification();
                showErrorNotification(`‚ùå Failed to analyze ${doc.name}: ${error.message}`);
                return [];
            }
        }
        
        // Notification functions for processing status
        function showProcessingNotification(message) {
            hideConfigurationNotification(); // Clear any existing notifications
            
            let notification = document.getElementById('processingNotification');
            if (!notification) {
                notification = document.createElement('div');
                notification.id = 'processingNotification';
                notification.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    background: linear-gradient(135deg, #667eea, #764ba2);
                    color: white;
                    padding: 15px 20px;
                    text-align: center;
                    z-index: 10000;
                    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
                    font-weight: 500;
                `;
                document.body.prepend(notification);
            }
            
            notification.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; gap: 10px;">
                    <div style="width: 20px; height: 20px; border: 2px solid rgba(255,255,255,0.3); border-top: 2px solid white; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                    ${message}
                </div>
            `;
            notification.style.display = 'block';
            
            // Add CSS animation if not already added
            if (!document.getElementById('spinAnimation')) {
                const style = document.createElement('style');
                style.id = 'spinAnimation';
                style.textContent = '@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }';
                document.head.appendChild(style);
            }
        }
        
        function updateProcessingNotification(message) {
            const notification = document.getElementById('processingNotification');
            if (notification) {
                notification.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: center; gap: 10px;">
                        <div style="width: 20px; height: 20px; border: 2px solid rgba(255,255,255,0.3); border-top: 2px solid white; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                        ${message}
                    </div>
                `;
            }
        }
        
        function hideProcessingNotification() {
            const notification = document.getElementById('processingNotification');
            if (notification) {
                notification.style.display = 'none';
            }
        }

        // Replace the loadDocumentAnnotations function with this Azure-enabled version:
        async function loadDocumentAnnotations(docId) {
            console.log('üîÑ Loading annotations for document:', docId);
            
            // Initialize
            documentAnnotations = [];
            
            // Try to load from Azure first, then fallback to localStorage
            if (currentUser) {
                try {
                    await loadAnnotationsFromAzure(docId);
                } catch (error) {
                    console.warn('‚ö†Ô∏è Failed to load from Azure, using localStorage:', error);
                    loadAnnotationsFromLocalStorage(docId);
                }
            } else {
                loadAnnotationsFromLocalStorage(docId);
            }
            
            // Load pre-annotations from document (AI-generated)
            const doc = allDocuments.find(d => d.id == docId);
            if (doc) {
                console.log('üìÑ Document found:', doc.name, 'Pre-annotations:', doc.preAnnotations?.length || 0);
                
                // If document doesn't have pre-annotations, try to load them
                if (!doc.preAnnotations || doc.preAnnotations.length === 0) {
                    console.log('üîç No pre-annotations found, attempting to load from API...');
                    try {
                        await loadPreAnnotations(doc);
                        console.log('‚úÖ Pre-annotation loading completed. Found:', doc.preAnnotations?.length || 0);
                    } catch (error) {
                        console.error('‚ùå Error loading pre-annotations:', error);
                    }
                } else {
                    console.log(`‚ú® Document already has ${doc.preAnnotations.length} pre-annotations`);
                }
                
                if (doc.preAnnotations && doc.preAnnotations.length > 0) {
                    console.log(`ü§ñ Found ${doc.preAnnotations.length} pre-annotations`);
                    
                    // Convert pre-annotations to our annotation format
                    const preAnnotations = doc.preAnnotations.map((preAnn, index) => {
                    // Handle both string and object formats
                    let cleanText = preAnn.text || preAnn.normalized_name || preAnn.medication || String(preAnn);
                    
                    return {
                        id: 'pre_' + Date.now() + '_' + index,
                        text: cleanText.trim(),
                        status: preAnn.active_status || preAnn.status || 'active',
                        timestamp: new Date().toISOString(),
                        source: 'main.py',
                        confidence: preAnn.confidence || 0.9,
                        rxnorm_code: preAnn.rx_cui || preAnn.rxnorm_code,
                        isPreAnnotation: true,
                        notes: '' // Initialize notes field for AI annotations
                    };
                });
                
                // Merge with user annotations (user annotations take precedence)
                const userTexts = documentAnnotations.map(ann => ann.text);
                const uniquePreAnnotations = preAnnotations.filter(
                    preAnn => !userTexts.includes(preAnn.text)
                );
                
                documentAnnotations = [...documentAnnotations, ...uniquePreAnnotations];
                console.log(`üìä Total annotations: ${documentAnnotations.length} (${uniquePreAnnotations.length} from AI)`);
                }
            }
            
            // Apply all annotations to the document
            setTimeout(() => {
                console.log('üé® Applying annotations to document...');
                documentAnnotations.forEach((annotation, index) => {
                    console.log(`üéØ ${index + 1}. Highlighting: "${annotation.text}" as ${annotation.status}`);
                    highlightText(annotation.text, annotation.status, false);
                });
                console.log(`‚úÖ Applied ${documentAnnotations.length} annotations`);
                updateAnnotationCount();
                updateAnnotationsList();

            }, 1000);
        }

        // Add helper functions for Azure loading:
        async function loadAnnotationsFromAzure(docId) {
            if (!currentUser) return;
            
            try {
                const adminConfigData = localStorage.getItem('azureConfigPublic') || localStorage.getItem('globalAzureConfig') || localStorage.getItem('azureConfig');
                if (!adminConfigData) {
                    throw new Error('Azure configuration not found');
                }
                
                const azureConfig = JSON.parse(adminConfigData);
                const userFolder = currentUser.email.replace(/[@.]/g, '_');
                const doc = allDocuments.find(d => d.id == docId);
                const fileName = `${docId}_${doc.name.replace(/[^a-zA-Z0-9]/g, '_')}_annotations.json`;
                const blobName = `${userFolder}/annotations/${fileName}`;
                
                const blobUrl = `https://${azureConfig.storageAccount}.blob.core.windows.net/${azureConfig.containerName}/${blobName}${azureConfig.sasToken}`;
                
                console.log('üì• Loading annotations from Azure:', blobUrl);
                
                const response = await fetch(blobUrl, {
                    method: 'GET',
                    headers: {
                        'Cache-Control': 'no-cache'
                    }
                });
                
                if (response.status === 404) {
                    console.log('‚ÑπÔ∏è No saved annotations found in Azure for this document');
                    return;
                }
                
                if (!response.ok) {
                    throw new Error(`Failed to load from Azure: ${response.status}`);
                }
                
                const annotationData = await response.json();
                
                if (annotationData.annotations && Array.isArray(annotationData.annotations)) {
                    // Filter out pre-annotations (they'll be loaded separately)
                    documentAnnotations = annotationData.annotations.filter(ann => !ann.isPreAnnotation);
                    console.log(`‚úÖ Loaded ${documentAnnotations.length} user annotations from Azure`);
                }
                
            } catch (error) {
                console.error('‚ùå Error loading from Azure:', error);
                throw error; // Re-throw to trigger fallback
            }
        }

        function loadAnnotationsFromLocalStorage(docId) {
            const savedAnnotations = JSON.parse(localStorage.getItem('documentAnnotations')) || {};
            const localAnnotations = savedAnnotations[docId] || [];
            
            // Filter out pre-annotations (they'll be loaded separately)
            documentAnnotations = localAnnotations.filter(ann => !ann.isPreAnnotation);
            console.log(`üì¶ Loaded ${documentAnnotations.length} user annotations from localStorage`);
        }


        function setAnnotationMode(mode) {
            currentAnnotationMode = mode;
            
            // Update button states
            document.getElementById('activeBtn').style.opacity = mode === 'active' ? '1' : '0.6';
            document.getElementById('inactiveBtn').style.opacity = mode === 'inactive' ? '1' : '0.6';
        }

        // Text selection and annotation
        // Replace the mouseup event listener (around line 1285) with this improved version:
        document.addEventListener('mouseup', function(e) {
    // Check if we're in the document viewer
            const documentViewer = document.getElementById('documentViewer');
            if (documentViewer.style.display !== 'block') return;
            
            // Small delay to ensure selection is complete
            setTimeout(() => {
                const selection = window.getSelection();
                const selectedText = selection.toString().trim();
                
                if (selectedText.length > 0 && selection.rangeCount > 0) {
                    const range = selection.getRangeAt(0);
                    const documentContent = document.getElementById('documentContent');
                    
                    // Check if the selection is within the document content
                    if (documentContent && (
                        documentContent.contains(range.commonAncestorContainer) || 
                        documentContent.contains(range.startContainer) ||
                        documentContent.contains(range.endContainer)
                    )) {
                        selectedRange = range;
                        console.log('Text selected:', selectedText); // Debug log
                        showSelectionPopup(e.pageX, e.pageY);
                    }
                } else {
                    hideSelectionPopup();
                }
            }, 10);
        });

        // Replace the showSelectionPopup function (around line 1320) with this:


        function hideSelectionPopup() {
            document.getElementById('selectionPopup').style.display = 'none';
            selectedRange = null;
        }

        // Add this function after the hideSelectionPopup function:
        function showSelectionPopup(x, y) {
            const popup = document.getElementById('selectionPopup');
            if (popup) {
                popup.style.display = 'block';
                
                // Improve positioning to stay within viewport
                const popupWidth = 200;
                const popupHeight = 60;
                
                const adjustedX = Math.min(x, window.innerWidth - popupWidth);
                const adjustedY = Math.max(y - popupHeight, 10);
                
                popup.style.left = adjustedX + 'px';
                popup.style.top = adjustedY + 'px';
                popup.style.zIndex = '1001';
                
                console.log('Showing selection popup at:', adjustedX, adjustedY); // Debug log
            }
        }

        // Replace the annotateSelection function (around line 1350) with this:
        function annotateSelection(status) {
            if (!selectedRange) return;
            
            const selectedText = selectedRange.toString().trim();
            if (selectedText.length === 0) return;
            
            console.log('Annotating selection:', selectedText, 'as', status); // Debug log
            
            // Create annotation
            const annotation = {
                id: Date.now(),
                text: selectedText,
                status: status,
                timestamp: new Date().toISOString(),
                position: selectedRange.startOffset,
                source: 'user',
                isPreAnnotation: false,
                notes: '' // Initialize with empty notes field
            };
            
            // Add to annotations array
            documentAnnotations.push(annotation);
            
            // Highlight the text with the specific range
            highlightText(selectedText, status, true, selectedRange.cloneRange());
            
            // Clear selection
            window.getSelection().removeAllRanges();
            hideSelectionPopup();
            
            // Update annotation count and list
            updateAnnotationCount();
            updateAnnotationsList();
            
            console.log('Annotation created:', annotation); // Debug log
        }

        function highlightText(text, status, isNew = false, range = null) {
            console.log('highlightText called:', { text, status, isNew });
            
            const content = document.getElementById('documentContent');
            if (!content) {
                console.error('Document content not found');
                return;
            }
            
            const className = status === 'active' ? 'highlight-active' : 'highlight-inactive';
            
            // If we have a specific range (new annotation), use it
            if (isNew && range) {
                try {
                    const span = document.createElement('span');
                    span.className = className;
                    span.onclick = () => removeAnnotation(text, status);
                    range.surroundContents(span);
                    console.log('Range highlighting successful');
                    return;
                } catch (error) {
                    console.log('Range highlighting failed, falling back to text search');
                }
            }
            
            // Text search method for loading saved annotations
            const walker = document.createTreeWalker(
                content,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            
            const textNodes = [];
            let node;
            while (node = walker.nextNode()) {
                textNodes.push(node);
            }
            
            console.log(`Found ${textNodes.length} text nodes`);
            
            // Look for the text in all text nodes
            for (let textNode of textNodes) {
                const parent = textNode.parentNode;
                
                // Skip already highlighted text
                if (parent.classList.contains('highlight-active') || parent.classList.contains('highlight-inactive')) {
                    continue;
                }
                
                const nodeText = textNode.textContent;
                const index = nodeText.indexOf(text);
                
                if (index !== -1) {
                    console.log(`Found text "${text}" in node:`, nodeText);
                    
                    const beforeText = nodeText.substring(0, index);
                    const matchText = nodeText.substring(index, index + text.length);
                    const afterText = nodeText.substring(index + text.length);
                    
                    const span = document.createElement('span');
                    span.className = className;
                    span.textContent = matchText;
                    span.onclick = () => removeAnnotation(text, status);
                    span.style.backgroundColor = status === 'active' ? '#d4edda' : '#f8d7da';
                    span.style.border = `2px solid ${status === 'active' ? '#28a745' : '#dc3545'}`;
                    span.style.borderRadius = '3px';
                    span.style.padding = '2px 4px';
                    
                    const fragment = document.createDocumentFragment();
                    if (beforeText) fragment.appendChild(document.createTextNode(beforeText));
                    fragment.appendChild(span);
                    if (afterText) fragment.appendChild(document.createTextNode(afterText));
                    
                    parent.replaceChild(fragment, textNode);
                    console.log(`Successfully highlighted: "${text}"`);
                    break; // Only highlight first occurrence
                }
            }
        }

        function removeAnnotation(text, status) {
            if (confirm('Remove this annotation?')) {
                // Remove from annotations array
                documentAnnotations = documentAnnotations.filter(ann => 
                    !(ann.text === text && ann.status === status)
                );
                
                // Remove the highlight from the document without refreshing entire document
                removeHighlightFromDocument(text, status);
                
                // Update UI elements
                updateAnnotationCount();
                updateAnnotationsList();
                
                // Save changes to storage
                saveAnnotationsToStorage();
                
                console.log('Removed annotation:', text, 'with status:', status);
                console.log('Remaining annotations:', documentAnnotations.length);
            }
        }

        // Replace the markAsActive and markAsInactive functions with these improved versions:
        function markAsActive() {
            console.log('Mark as Active clicked');
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();
            
            if (selectedText.length > 0 && selection.rangeCount > 0) {
                selectedRange = selection.getRangeAt(0).cloneRange(); // Clone the range
                annotateSelection('active');
            } else {
                alert('Please select some text first');
            }
        }

        function markAsInactive() {
            console.log('Mark as Inactive clicked');
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();
            
            if (selectedText.length > 0 && selection.rangeCount > 0) {
                selectedRange = selection.getRangeAt(0).cloneRange(); // Clone the range
                annotateSelection('inactive');
            } else {
                alert('Please select some text first');
            }
        }

    

        function refreshDocumentDisplay() {
            if (currentDocument) {
                openDocumentViewer(currentDocument);
            }
        }

        function clearSelection() {
            window.getSelection().removeAllRanges();
            hideSelectionPopup();
        }

        // Replace the updateAnnotationCount function (around line 1450) with this fixed version:
        function updateAnnotationCount() {
            // Make sure documentAnnotations is an array, not an object
            if (!Array.isArray(documentAnnotations)) {
                documentAnnotations = [];
            }
            
            const count = documentAnnotations.length;
            const notesStats = getNotesStatistics();
            
            console.log('üìä Updating annotation count:', count, 'annotations:', documentAnnotations);
            console.log('üìù Notes stats:', notesStats);
            
            const countElement = document.getElementById('annotationCount');
            if (countElement) {
                // Show total count with notes indicator if any annotations have notes
                if (notesStats.withNotes > 0) {
                    countElement.textContent = `${count} (${notesStats.withNotes} üìù)`;
                    countElement.title = `${count} total annotations, ${notesStats.withNotes} with notes`;
                } else {
                    countElement.textContent = count;
                    countElement.title = `${count} total annotations`;
                }
            }
        }

        // Replace the updateAnnotationsList function with this enhanced version that passes the full text:
        function updateAnnotationsList() {
            const list = document.getElementById('annotationsList');
            
            if (documentAnnotations.length === 0) {
                list.innerHTML = '<p style="text-align: center; color: #666; padding: 1rem;">No annotations yet</p>';
                return;
            }
            
            let html = '';
            documentAnnotations.forEach((annotation, index) => {
                const statusClass = annotation.status === 'active' ? 'status-active' : 'status-inactive';
                const sourceIcon = annotation.isPreAnnotation ? 'ü§ñ' : 'üë§';
                const sourceText = annotation.isPreAnnotation ? 'AI Detected' : 'User Added';
                const confidenceText = annotation.confidence ? ` (${Math.round(annotation.confidence * 100)}%)` : '';
                
                // Escape quotes for onclick attribute
                const escapedText = annotation.text.replace(/'/g, "\\'").replace(/"/g, '\\"');
                const displayText = annotation.text.length > 50 ? 
                    annotation.text.substring(0, 50) + '...' : 
                    annotation.text;
                
                // Add has-notes class if annotation has notes
                const hasNotesClass = (annotation.notes && annotation.notes.trim()) ? 'has-notes' : '';
                
                html += `
                    <div class="annotation-item ${hasNotesClass}" onclick="scrollToAnnotation('${escapedText}')" style="cursor: pointer; transition: background-color 0.2s;">
                        <div class="annotation-text" title="${annotation.text}">
                            <strong>"${displayText}"</strong>
                        </div>
                        <div class="annotation-status ${statusClass}">${annotation.status.toUpperCase()}</div>
                        <div style="font-size: 0.75rem; color: #999; margin-top: 0.25rem;">
                            ${sourceIcon} ${sourceText}${confidenceText}
                            <br>${new Date(annotation.timestamp).toLocaleString()}
                            ${annotation.rxnorm_code ? `<br>RxNorm: ${annotation.rxnorm_code}` : ''}
                        </div>
                        <div style="margin-top: 0.5rem;">
                            <label style="font-size: 0.75rem; color: #666; display: block; margin-bottom: 0.25rem;">Notes:</label>
                            <textarea 
                                id="notes_${annotation.id}" 
                                placeholder="Add notes or comments..."
                                onblur="updateAnnotationNotes('${annotation.id}', this.value)"
                                onclick="event.stopPropagation()"
                                style="width: 100%; min-height: 40px; padding: 0.25rem; border: 1px solid #ddd; border-radius: 3px; font-size: 0.75rem; resize: vertical; font-family: inherit;"
                            >${annotation.notes || ''}</textarea>
                        </div>
                        ${annotation.isPreAnnotation ? 
                            `<div style="margin-top: 0.5rem; display: flex; gap: 0.25rem; flex-wrap: wrap;">
                                <button onclick="event.stopPropagation(); changeAnnotationStatus('${annotation.id}', 'active')" 
                                        style="padding: 0.25rem 0.5rem; background: ${annotation.status === 'active' ? '#28a745' : '#6c757d'}; 
                                            color: white; border: none; border-radius: 3px; font-size: 0.7rem; flex: 1;">
                                    ${annotation.status === 'active' ? '‚úì Active' : 'Set Active'}
                                </button>
                                <button onclick="event.stopPropagation(); changeAnnotationStatus('${annotation.id}', 'inactive')" 
                                        style="padding: 0.25rem 0.5rem; background: ${annotation.status === 'inactive' ? '#dc3545' : '#6c757d'}; 
                                            color: white; border: none; border-radius: 3px; font-size: 0.7rem; flex: 1;">
                                    ${annotation.status === 'inactive' ? '‚úì Inactive' : 'Set Inactive'}
                                </button>
                            </div>` : 
                            `<div style="margin-top: 0.5rem; display: flex; gap: 0.25rem;">
                                <button onclick="event.stopPropagation(); changeAnnotationStatus('${annotation.id}', '${annotation.status === 'active' ? 'inactive' : 'active'}')" 
                                        style="padding: 0.25rem 0.5rem; background: #6c757d; color: white; border: none; 
                                            border-radius: 3px; font-size: 0.7rem; flex: 1;">
                                    Change to ${annotation.status === 'active' ? 'Inactive' : 'Active'}
                                </button>
                                <button onclick="event.stopPropagation(); removeAnnotationById('${annotation.id}')" 
                                        style="padding: 0.25rem 0.5rem; background: #dc3545; color: white; border: none; 
                                            border-radius: 3px; font-size: 0.7rem;">
                                    Remove
                                </button>
                            </div>`
                        }
                    </div>
                `;
            });
            
            list.innerHTML = html;
        }

        // Helper function to check annotations with notes
        function getAnnotationsWithNotes() {
            return documentAnnotations.filter(ann => ann.notes && ann.notes.trim() !== '');
        }

        // Helper function to get notes statistics
        function getNotesStatistics() {
            const annotationsWithNotes = getAnnotationsWithNotes();
            const totalAnnotations = documentAnnotations.length;
            
            return {
                total: totalAnnotations,
                withNotes: annotationsWithNotes.length,
                withoutNotes: totalAnnotations - annotationsWithNotes.length,
                percentage: totalAnnotations > 0 ? Math.round((annotationsWithNotes.length / totalAnnotations) * 100) : 0,
                annotationsWithNotes: annotationsWithNotes
            };
        }

        // Function to log notes information to console (for debugging)
        function showNotesInfo() {
            const stats = getNotesStatistics();
            console.log('üìù Notes Statistics:', stats);
            
            if (stats.withNotes > 0) {
                console.log('üìù Annotations with notes:');
                stats.annotationsWithNotes.forEach((ann, index) => {
                    console.log(`${index + 1}. "${ann.text.substring(0, 50)}..." - Note: "${ann.notes}"`);
                });
            } else {
                console.log('üìù No annotations have notes yet');
            }
            
            return stats;
        }

        // Function to update annotation notes
        function updateAnnotationNotes(annotationId, newNotes) {
            console.log('üìù Updating notes for annotation:', annotationId, 'New notes:', newNotes);
            
            const annotation = documentAnnotations.find(ann => ann.id == annotationId);
            if (annotation) {
                annotation.notes = newNotes;
                console.log('‚úÖ Notes updated for annotation:', annotation.text.substring(0, 30), '...');
                
                // Auto-save annotations after a short delay (debounced)
                clearTimeout(window.notesUpdateTimeout);
                window.notesUpdateTimeout = setTimeout(() => {
                    saveAnnotations();
                }, 2000); // Save 2 seconds after user stops typing
            } else {
                console.error('‚ùå Annotation not found for ID:', annotationId);
            }
        }

        function changeAnnotationStatus(annotationId, newStatus) {
            console.log('üîÑ Attempting to change annotation status:', {annotationId, newStatus});
            console.log('üìã Current annotations:', documentAnnotations.map(a => ({id: a.id, text: a.text.substring(0, 20), status: a.status})));
            
            const annotation = documentAnnotations.find(ann => ann.id == annotationId); // Use == for loose comparison
            console.log('üîç Found annotation:', annotation);
            
            if (annotation && annotation.status !== newStatus) {
                const oldStatus = annotation.status;
                annotation.status = newStatus;
                annotation.timestamp = new Date().toISOString();
                
                console.log(`‚úÖ Changed annotation "${annotation.text.substring(0, 30)}..." from ${oldStatus} to ${newStatus}`);
                
                // Re-highlight the text with new status
                rehighlightAnnotation(annotation, oldStatus);
                
                // Update the display
                updateAnnotationsList();
                updateAnnotationCount();
                
                // Auto-save to Azure
                autoSaveAnnotations();
            } else if (!annotation) {
                console.error('‚ùå Annotation not found with ID:', annotationId);
                alert('Error: Annotation not found. Please refresh the page and try again.');
            } else {
                console.log('‚ÑπÔ∏è Annotation already has status:', newStatus);
            }
        }

        // Add auto-save with debouncing:
        let autoSaveTimeout;
        async function autoSaveAnnotations() {
            // Clear previous timeout
            clearTimeout(autoSaveTimeout);
            
            // Set new timeout to auto-save after 5 seconds of no changes (increased delay)
            autoSaveTimeout = setTimeout(async () => {
                try {
                    console.log('üíæ Starting auto-save...');
                    await saveAnnotationsToAzure();
                    console.log('‚úÖ Auto-saved annotations to Azure');
                    
                    // Show subtle indicator
                    const indicator = document.createElement('div');
                    indicator.textContent = '‚òÅÔ∏è Saved';
                    indicator.style.cssText = `
                        position: fixed; top: 20px; right: 20px; 
                        background: #28a745; color: white; 
                        padding: 0.5rem 1rem; border-radius: 6px; 
                        font-size: 0.875rem; z-index: 1100;
                        opacity: 0; transition: opacity 0.3s;
                    `;
                    document.body.appendChild(indicator);
                    
                    setTimeout(() => indicator.style.opacity = '1', 100);
                    setTimeout(() => {
                        indicator.style.opacity = '0';
                        setTimeout(() => {
                            if (document.body.contains(indicator)) {
                                document.body.removeChild(indicator);
                            }
                        }, 300);
                    }, 2000);
                    
                } catch (error) {
                    console.warn('‚ö†Ô∏è Auto-save failed, using localStorage fallback:', error);
                    saveAnnotationsToStorage(); // Fallback to localStorage
                }
            }, 5000); // 5 second delay (increased from 3)
        }

        // Add helper function for just Azure save (without UI feedback):
        async function saveAnnotationsToAzure() {
            if (!currentDocument || !currentUser) return;
            
            const adminConfigData = localStorage.getItem('azureConfigPublic') || localStorage.getItem('globalAzureConfig') || localStorage.getItem('azureConfig');
            if (!adminConfigData) {
                throw new Error('Azure configuration not found');
            }
            
            const azureConfig = JSON.parse(adminConfigData);
            
            const annotationData = {
                documentId: currentDocument.id,
                documentName: currentDocument.name,
                documentBlobName: currentDocument.blobName,
                userEmail: currentUser.email,
                userName: currentUser.name,
                userRole: currentUser.role,
                annotations: documentAnnotations,
                lastModified: new Date().toISOString(),
                version: "1.0",
                statistics: {
                    totalAnnotations: documentAnnotations.length,
                    activeCount: documentAnnotations.filter(ann => ann.status === 'active').length,
                    inactiveCount: documentAnnotations.filter(ann => ann.status === 'inactive').length,
                    aiGeneratedCount: documentAnnotations.filter(ann => ann.isPreAnnotation).length,
                    userCreatedCount: documentAnnotations.filter(ann => !ann.isPreAnnotation).length
                }
            };
            
            const userFolder = currentUser.email.replace(/[@.]/g, '_');
            const fileName = `${currentDocument.id}_${currentDocument.name.replace(/[^a-zA-Z0-9]/g, '_')}_annotations.json`;
            const blobName = `${userFolder}/annotations/${fileName}`;
            
            const blobUrl = `https://${azureConfig.storageAccount}.blob.core.windows.net/${azureConfig.containerName}/${blobName}${azureConfig.sasToken}`;
            
            const response = await fetch(blobUrl, {
                method: 'PUT',
                headers: {
                    'x-ms-blob-type': 'BlockBlob',
                    'Content-Type': 'application/json',
                    'x-ms-meta-user': currentUser.email,
                    'x-ms-meta-document': currentDocument.name
                },
                body: JSON.stringify(annotationData, null, 2)
            });
            
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Failed to save to Azure: ${response.status} ${errorText}`);
            }
        }

        function rehighlightAnnotation(annotation, oldStatus) {
            // Find and remove the old highlight
            const oldClassName = oldStatus === 'active' ? 'highlight-active' : 'highlight-inactive';
            const newClassName = annotation.status === 'active' ? 'highlight-active' : 'highlight-inactive';
            
            const highlights = document.querySelectorAll(`.${oldClassName}`);
            for (let highlight of highlights) {
                if (highlight.textContent === annotation.text) {
                    // Change the class and styling
                    highlight.className = newClassName;
                    highlight.style.backgroundColor = annotation.status === 'active' ? '#d4edda' : '#f8d7da';
                    highlight.style.border = `2px solid ${annotation.status === 'active' ? '#28a745' : '#dc3545'}`;
                    
                    // Update the click handler
                    highlight.onclick = () => removeAnnotation(annotation.text, annotation.status);
                    break;
                }
            }
        }

        function removeAnnotationById(annotationId) {
            console.log('üóëÔ∏è Attempting to remove annotation with ID:', annotationId);
            console.log('üìã Current annotations:', documentAnnotations.map(a => ({id: a.id, text: a.text.substring(0, 20)})));
            
            if (confirm('Remove this annotation?')) {
                const annotation = documentAnnotations.find(ann => ann.id == annotationId); // Use == for loose comparison
                console.log('üîç Found annotation:', annotation);
                
                if (annotation) {
                    // Remove from annotations array
                    const originalLength = documentAnnotations.length;
                    documentAnnotations = documentAnnotations.filter(ann => ann.id != annotationId); // Use != for loose comparison
                    console.log(`üìä Removed annotation. Count: ${originalLength} ‚Üí ${documentAnnotations.length}`);
                    
                    // Remove the highlight from the document immediately
                    removeHighlightFromDocument(annotation.text, annotation.status);
                    
                    // Update the UI elements
                    updateAnnotationCount();
                    updateAnnotationsList();
                    
                    // Auto-save to Azure (with delay to avoid conflicts)
                    autoSaveAnnotations();
                    
                    console.log('‚úÖ Successfully removed annotation:', annotation.text);
                } else {
                    console.error('‚ùå Annotation not found with ID:', annotationId);
                    alert('Error: Annotation not found. Please refresh the page and try again.');
                }
            }
        }

        function removeHighlightFromDocument(text, status) {
            const className = status === 'active' ? 'highlight-active' : 'highlight-inactive';
            const highlights = document.querySelectorAll(`.${className}`);
            
            // Convert NodeList to Array to avoid issues with live collection
            const highlightArray = Array.from(highlights);
            
            for (let highlight of highlightArray) {
                if (highlight.textContent.trim() === text.trim()) {
                    // Replace the highlight span with plain text
                    const textNode = document.createTextNode(highlight.textContent);
                    if (highlight.parentNode) {
                        highlight.parentNode.replaceChild(textNode, highlight);
                        console.log('Removed highlight for:', text);
                    }
                    break;
                }
            }
        }

        function saveAnnotationsToStorage() {
            if (!currentDocument) return;
            
            const allAnnotations = JSON.parse(localStorage.getItem('documentAnnotations')) || {};
            allAnnotations[currentDocument.id] = documentAnnotations;
            localStorage.setItem('documentAnnotations', JSON.stringify(allAnnotations));
        }

        // Replace the scrollToAnnotation function (around line 1950) with this enhanced version:
        function scrollToAnnotation(text) {
            console.log('üîç Scrolling to annotation:', text);
            
            // Find all highlights in the document
            const highlights = document.querySelectorAll('.highlight-active, .highlight-inactive');
            let foundHighlight = null;
            
            // Look for exact or partial text match
            for (let highlight of highlights) {
                const highlightText = highlight.textContent.trim();
                
                // Try exact match first
                if (highlightText === text) {
                    foundHighlight = highlight;
                    break;
                }
                
                // Try partial match (for truncated text in annotations list)
                if (text.length > 50 && highlightText.includes(text.substring(0, 50))) {
                    foundHighlight = highlight;
                    break;
                }
                
                // Try reverse partial match
                if (highlightText.includes(text) || text.includes(highlightText)) {
                    foundHighlight = highlight;
                    break;
                }
            }
            
            if (foundHighlight) {
                console.log('‚úÖ Found highlight, scrolling to it');
                
                // Scroll to the highlight
                foundHighlight.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'center',
                    inline: 'nearest'
                });
                
                // Add visual emphasis with animation
                const originalStyle = {
                    boxShadow: foundHighlight.style.boxShadow,
                    transform: foundHighlight.style.transform,
                    transition: foundHighlight.style.transition
                };
                
                // Apply highlight animation
                foundHighlight.style.transition = 'all 0.5s ease';
                foundHighlight.style.boxShadow = '0 0 20px #667eea, 0 0 40px #667eea';
                foundHighlight.style.transform = 'scale(1.05)';
                
                // Flash effect
                let flashCount = 0;
                const flashInterval = setInterval(() => {
                    foundHighlight.style.opacity = foundHighlight.style.opacity === '0.5' ? '1' : '0.5';
                    flashCount++;
                    
                    if (flashCount >= 6) { // Flash 3 times (6 changes)
                        clearInterval(flashInterval);
                        foundHighlight.style.opacity = '1';
                    }
                }, 200);
                
                // Remove effects after animation
                setTimeout(() => {
                    foundHighlight.style.boxShadow = originalStyle.boxShadow;
                    foundHighlight.style.transform = originalStyle.transform;
                    foundHighlight.style.transition = originalStyle.transition;
                }, 3000);
                
            } else {
                console.warn('‚ùå Highlight not found for text:', text);
                
                // Show a message to user
                const message = document.createElement('div');
                message.textContent = `Could not locate "${text.substring(0, 30)}..." in the document`;
                message.style.cssText = `
                    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                    background: #f8d7da; color: #721c24; padding: 1rem 2rem;
                    border: 1px solid #f5c6cb; border-radius: 8px;
                    font-size: 0.875rem; z-index: 2000;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                `;
                document.body.appendChild(message);
                
                setTimeout(() => {
                    document.body.removeChild(message);
                }, 3000);
            }
        }

        function toggleAnnotationsPanel() {
            const panel = document.getElementById('annotationsPanel');
            if (panel.style.display === 'block') {
                panel.style.display = 'none';
            } else {
                panel.style.display = 'block';
                updateAnnotationsList();
            }
        }



        // Replace the saveAnnotations function (around line 1800) with this Azure-enabled version:
        async function saveAnnotations() {
            if (!currentDocument || !currentUser) return;
            
            try {
                // Show saving state
                const saveButton = event.target;
                const originalText = saveButton.textContent;
                saveButton.textContent = 'Saving...';
                saveButton.style.background = '#ffc107';
                saveButton.disabled = true;
                
                // Get Azure config (try both public and admin configs)
                const adminConfigData = localStorage.getItem('azureConfigPublic') || localStorage.getItem('globalAzureConfig') || localStorage.getItem('azureConfig');
                if (!adminConfigData) {
                    throw new Error('Azure configuration not found. Please contact administrator.');
                }
                
                const azureConfig = JSON.parse(adminConfigData);
                
                if (!azureConfig.sasToken || !azureConfig.storageAccount || !azureConfig.containerName) {
                    throw new Error('Incomplete Azure configuration. Please contact administrator.');
                }
                
                // Create annotation data with metadata
                const annotationData = {
                    documentId: currentDocument.id,
                    documentName: currentDocument.name,
                    documentBlobName: currentDocument.blobName,
                    userEmail: currentUser.email,
                    userName: currentUser.name,
                    userRole: currentUser.role,
                    annotations: documentAnnotations,
                    lastModified: new Date().toISOString(),
                    version: "1.0",
                    statistics: {
                        totalAnnotations: documentAnnotations.length,
                        activeCount: documentAnnotations.filter(ann => ann.status === 'active').length,
                        inactiveCount: documentAnnotations.filter(ann => ann.status === 'inactive').length,
                        aiGeneratedCount: documentAnnotations.filter(ann => ann.isPreAnnotation).length,
                        userCreatedCount: documentAnnotations.filter(ann => !ann.isPreAnnotation).length
                    }
                };
                
                // Create blob path: userEmail/annotations/documentId_annotations.json
                const userFolder = currentUser.email.replace(/[@.]/g, '_'); // Replace @ and . for valid folder names
                const fileName = `${currentDocument.id}_${currentDocument.name.replace(/[^a-zA-Z0-9]/g, '_')}_annotations.json`;
                const blobName = `${userFolder}/annotations/${fileName}`;
                
                // Construct Azure Blob URL with SAS token
                const blobUrl = `https://${azureConfig.storageAccount}.blob.core.windows.net/${azureConfig.containerName}/${blobName}${azureConfig.sasToken}`;
                
                console.log('Saving annotations to Azure:', blobUrl);
                
                // Upload to Azure Blob Storage
                const response = await fetch(blobUrl, {
                    method: 'PUT',
                    headers: {
                        'x-ms-blob-type': 'BlockBlob',
                        'Content-Type': 'application/json',
                        'x-ms-blob-content-disposition': `inline; filename="${fileName}"`,
                        'x-ms-meta-user': currentUser.email,
                        'x-ms-meta-document': currentDocument.name,
                        'x-ms-meta-annotationcount': documentAnnotations.length.toString()
                    },
                    body: JSON.stringify(annotationData, null, 2)
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Failed to save to Azure: ${response.status} ${errorText}`);
                }
                
                // Also save to localStorage as backup
                const allAnnotations = JSON.parse(localStorage.getItem('documentAnnotations')) || {};
                allAnnotations[currentDocument.id] = documentAnnotations;
                localStorage.setItem('documentAnnotations', JSON.stringify(allAnnotations));
                
                // Show success with cloud icon
                saveButton.textContent = '‚òÅÔ∏è Saved to Cloud!';
                saveButton.style.background = '#28a745';
                
                console.log('‚úÖ Annotations saved successfully to Azure and localStorage');
                
                // Create user annotation summary file
                await updateUserAnnotationSummary();
                
                setTimeout(() => {
                    saveButton.textContent = originalText;
                    saveButton.style.background = '#28a745';
                    saveButton.disabled = false;
                }, 3000);
                
            } catch (error) {
                console.error('‚ùå Error saving annotations:', error);
                
                // Fallback to localStorage only
                const allAnnotations = JSON.parse(localStorage.getItem('documentAnnotations')) || {};
                allAnnotations[currentDocument.id] = documentAnnotations;
                localStorage.setItem('documentAnnotations', JSON.stringify(allAnnotations));
                
                // Show error but indicate localStorage backup worked
                const saveButton = event.target;
                saveButton.textContent = 'üíæ Saved Locally';
                saveButton.style.background = '#ffc107';
                
                setTimeout(() => {
                    saveButton.textContent = 'Save';
                    saveButton.style.background = '#28a745';
                    saveButton.disabled = false;
                }, 3000);
                
                alert(`‚òÅÔ∏è Cloud save failed: ${error.message}\nüíæ Annotations saved locally as backup.`);
            }
        }


        // Add this function after the saveAnnotations function:
        async function updateUserAnnotationSummary() {
            if (!currentUser) return;
            
            try {
                // Get Azure config
                const adminConfigData = localStorage.getItem('azureConfigPublic') || localStorage.getItem('globalAzureConfig') || localStorage.getItem('azureConfig');
                if (!adminConfigData) return;
                
                const azureConfig = JSON.parse(adminConfigData);
                const userFolder = currentUser.email.replace(/[@.]/g, '_');
                
                // Create user summary data
                const userSummary = {
                    userEmail: currentUser.email,
                    userName: currentUser.name,
                    userRole: currentUser.role,
                    lastActivity: new Date().toISOString(),
                    totalDocumentsAnnotated: 1, // This would be calculated from actual data
                    totalAnnotations: documentAnnotations.length,
                    documentsWorked: [
                        {
                            documentId: currentDocument.id,
                            documentName: currentDocument.name,
                            lastModified: new Date().toISOString(),
                            annotationCount: documentAnnotations.length,
                            activeCount: documentAnnotations.filter(ann => ann.status === 'active').length,
                            inactiveCount: documentAnnotations.filter(ann => ann.status === 'inactive').length
                        }
                    ]
                };
                
                // Save user summary
                const summaryBlobName = `${userFolder}/user_annotation_summary.json`;
                const summaryBlobUrl = `https://${azureConfig.storageAccount}.blob.core.windows.net/${azureConfig.containerName}/${summaryBlobName}${azureConfig.sasToken}`;
                
                await fetch(summaryBlobUrl, {
                    method: 'PUT',
                    headers: {
                        'x-ms-blob-type': 'BlockBlob',
                        'Content-Type': 'application/json',
                        'x-ms-meta-user': currentUser.email,
                        'x-ms-meta-lastupdate': new Date().toISOString()
                    },
                    body: JSON.stringify(userSummary, null, 2)
                });
                
                console.log('üìä User summary updated successfully');
                
            } catch (error) {
                console.warn('‚ö†Ô∏è Failed to update user summary:', error);
            }
        }

        function closeViewer() {
            document.getElementById('documentViewer').style.display = 'none';
            document.getElementById('annotationsPanel').style.display = 'none';
            currentDocument = null;
            documentAnnotations = [];

            const countElement = document.getElementById('annotationCount');
            if (countElement) {
                countElement.textContent = '0';
            }
        }

        // Initialize annotation mode
        setAnnotationMode('active');
        if (typeof updateAnnotationCount !== 'undefined') {
            updateAnnotationCount();
        }
            
        // Global helper functions for testing/debugging (accessible from browser console)
        window.checkNotes = function() {
            return showNotesInfo();
        };
        
        window.getAnnotationsWithNotes = function() {
            return documentAnnotations.filter(ann => ann.notes && ann.notes.trim() !== '');
        };
        
        window.exportAnnotationsWithNotes = function() {
            const annotationsWithNotes = getAnnotationsWithNotes();
            const exportData = {
                documentName: currentDocument ? currentDocument.name : 'Unknown',
                timestamp: new Date().toISOString(),
                annotations: annotationsWithNotes.map(ann => ({
                    text: ann.text,
                    status: ann.status,
                    notes: ann.notes,
                    source: ann.source,
                    isPreAnnotation: ann.isPreAnnotation,
                    timestamp: ann.timestamp
                }))
            };
            console.log('üìù Exporting annotations with notes:', exportData);
            return exportData;
        };
    </script>
</body>
</html>